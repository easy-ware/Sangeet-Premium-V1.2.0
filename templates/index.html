<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Enhanced Music Player</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="icon" type="image/gif" href="/data/download/icons/sangeet-home" sizes="any">
  <link href="/design/index" rel="stylesheet">
  <style id="version-info">
    @keyframes float {

      0%,
      100% {
        transform: translateY(0) rotate(0deg);
      }

      50% {
        transform: translateY(-20px) rotate(10deg);
      }
    }

    @keyframes twinkle {

      0%,
      100% {
        opacity: 0;
      }

      50% {
        opacity: 1;
      }
    }

    .music-note {
      position: absolute;
      font-size: 24px;
      pointer-events: none;
      animation: float 3s infinite, twinkle 3s infinite;
    }
  </style>
  <style>
    .glass-button {
      position: relative;
      padding: 16px 32px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 12px;
      transition: all 0.3s ease;
      overflow: hidden;
      text-decoration: none;
      /* Added to remove underline from anchor */
    }

    .glass-button:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
    }

    .glass-button:active {
      transform: translateY(0px);
    }

    .button-text {
      color: #2a2a2a;
      font-family: system-ui, -apple-system, sans-serif;
      font-weight: 500;
      font-size: 18px;
      z-index: 1;
    }

    .source-icon {
      width: 24px;
      height: 24px;
      animation: bounce 2s infinite;
    }

    .sparkle {
      position: absolute;
      width: 4px;
      height: 4px;
      border-radius: 50%;
      background: #fff;
      animation: sparkle 1.5s infinite;
    }

    @keyframes bounce {

      0%,
      100% {
        transform: translateY(0);
      }

      50% {
        transform: translateY(-4px);
      }
    }

    @keyframes sparkle {
      0% {
        transform: scale(0) rotate(0deg);
        opacity: 0;
      }

      50% {
        transform: scale(1) rotate(180deg);
        opacity: 1;
      }

      100% {
        transform: scale(0) rotate(360deg);
        opacity: 0;
      }
    }
  </style>
  <style>
    /* Playlist Header */
.pl-header {
  display: flex;
  align-items: center;
  padding: 1rem;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

/* Back Button */
.pl-back-btn {
  background: none;
  border: none;
  color: var(--primary-light);
  cursor: pointer;
  margin-right: 1rem;
}

.pl-back-btn:hover {
  color: var(--accent-color);
}

/* Enhanced Song Item */
.pl-song-item {
  display: flex;
  align-items: center;
  padding: 0.5rem;
  background: var(--surface-color);
  border-radius: 4px;
  margin-bottom: 0.3rem;
}

.pl-song-item:hover {
  background: var(--card-color);
}

/* Song Thumbnail */
.pl-song-thumb {
  width: 50px;
  height: 50px;
  object-fit: cover;
  border-radius: 4px;
  margin-right: 1rem;
}

/* Song Information */
.pl-song-info {
  flex-grow: 1;
}

.pl-song-title {
  font-weight: 500;
  color: var(--text-primary);
}

.pl-song-artist {
  font-size: 0.9rem;
  color: var(--text-secondary);
}

/* Control Buttons */
.pl-control-btn {
  background: none;
  border: none;
  color: var(--primary-light);
  cursor: pointer;
  padding: 0.5rem;
  opacity: 0;
  transition: opacity 0.3s;
}

.pl-song-item:hover .pl-control-btn {
  opacity: 1;
}
  </style>
</head>

<body>
  <div class="container">
    <!-- Enhanced Search Section -->
    <div class="search-container">
      <input type="text" class="search-input" id="searchInput" placeholder="Search for songs or tap mic to speak..." />
      <div class="search-icons">
        <span class="material-icons search-icon" id="micIcon">mic</span>
        <span class="material-icons search-icon broom-icon" id="broomIcon">cleaning_services</span>
      </div>
    </div>

    <!-- Insights Modal Section -->
    <div class="insights-modal" id="insightsModal">
      <div class="insights-content">
        <div class="insights-header">
          <h2>Listening Insights</h2>
          <button class="close-button" id="closeInsights">
            <span class="material-icons">close</span>
          </button>
        </div>

        <div class="insights-body">
          <!-- Overview Insight Section -->
          <section class="insight-section">
            <h3>Overview</h3>
            <div class="stats-grid">
              <div class="stat-card">
                <span class="material-icons">schedule</span>
                <div class="stat-value" id="totalListeningTime">0h</div>
                <div class="stat-label">Total Time</div>
              </div>
              <div class="stat-card">
                <span class="material-icons">music_note</span>
                <div class="stat-value" id="totalSongs">0</div>
                <div class="stat-label">Songs Played</div>
              </div>
              <div class="stat-card">
                <span class="material-icons">group</span>
                <div class="stat-value" id="uniqueArtists">0</div>
                <div class="stat-label">Artists</div>
              </div>
              <div class="stat-card">
                <span class="material-icons">trending_up</span>
                <div class="stat-value" id="averageDaily">0</div>
                <div class="stat-label">Daily Average</div>
              </div>
            </div>
          </section>

          <!-- Top Artists Insight Section -->
          <section class="insight-section">
            <h3>Top Artists</h3>
            <div class="top-artists-list" id="topArtistsList"></div>
          </section>

          <!-- Listening Patterns Insight Section -->
          <section class="insight-section">
            <h3>Listening Patterns</h3>
            <div class="patterns-container">
              <div class="pattern-chart">
                <h4>Daily Activity</h4>
                <div id="dailyPatternChart"></div>
              </div>
              <div class="pattern-chart">
                <h4>Hourly Activity</h4>
                <div id="hourlyPatternChart"></div>
              </div>
            </div>
          </section>

          <!-- Recent Activity Insight Section -->
          <section class="insight-section">
            <h3>Recent Activity</h3>
            <div class="recent-activity-list" id="recentActivityList"></div>
          </section>


        </div>
      </div>
    </div>

    <!-- Results Grid Section -->
    <div class="results-container" id="resultsContainer"></div>

    <!-- Infinite Loader Section -->
    <div id="infiniteLoader" style="text-align:center; color:var(--text-secondary); display:none;">
      Loading more...
    </div>
  </div>

  <!-- Mini Player Section -->
  <div class="mini-player hidden" id="miniPlayer">
    <div class="mini-player-info">
      <img src="" alt="Cover" class="mini-player-thumb" id="miniPlayerThumb" />
      <div class="mini-player-text">
        <div class="mini-player-title" id="miniPlayerTitle">Title</div>
        <div class="mini-player-artist" id="miniPlayerArtist">Artist</div>
      </div>
    </div>

    <div class="player-controls">
      <button class="control-button" id="prevButton">
        <span class="material-icons">skip_previous</span>
      </button>
      <button class="control-button play-pause" id="playButton">
        <span class="material-icons">play_circle</span>
      </button>
      <button class="control-button" id="nextButton">
        <span class="material-icons">skip_next</span>
      </button>
    </div>

    <div class="progress-container" id="progressContainer">
      <div class="progress-bar">
        <div class="progress" id="progressBar"></div>
        <div class="progress-skeleton" id="progressSkeleton"></div>
        <div class="progress-hover" id="progressHover"></div>
      </div>
      <div class="time-indicator">
        <span id="currentTime">0:00</span>
        <span id="totalTime">0:00</span>
      </div>
    </div>

    <div class="volume-control">
      <button class="control-button" id="volumeButton">
        <span class="material-icons">volume_up</span>
      </button>
      <input type="range" class="volume-slider" min="0" max="100" value="100" id="volumeSlider" />
    </div>

    <button class="control-button expand" id="expandButton">
      <span class="material-icons">expand_less</span>
    </button>
  </div>

  <!-- Enhanced Full Player Section -->
  <div class="full-player" id="fullPlayer">
    <div class="full-player-header">
      <button class="control-button" id="minimizeButton">
        <span class="material-icons">expand_more</span>
      </button>
    </div>

    <div class="full-player-content">
      <div class="full-player-main">
        <div class="full-player-art">
          <img src="" alt="Cover" id="fullPlayerArt">
        </div>

        <div class="full-player-info">
          <div class="marquee">
            <div class="text" id="fullPlayerTitle">Choose a song to play</div>
          </div>
          <div class="full-player-artist" id="fullPlayerArtist">-</div>

          <div class="player-controls">
            <button class="control-button" id="fullPrevButton">
              <span class="material-icons">skip_previous</span>
            </button>
            <button class="control-button play-pause" id="fullPlayButton">
              <span class="material-icons">play_arrow</span>
            </button>
            <button class="control-button" id="fullNextButton">
              <span class="material-icons">skip_next</span>
            </button>
            <!-- Add to Playlist Button -->
            <button class="control-button" id="addToPlaylistButton" title="Add to Playlist">
              <span class="material-icons">playlist_add</span>
            </button>
          </div>

          <div class="progress-container" id="fullProgressContainer">
            <div class="progress-bar">
              <div class="progress" id="fullProgressBar"></div>
              <div class="progress-hover" id="fullProgressHover"></div>
            </div>
            <div class="time-indicator">
              <span id="fullCurrentTime">0:00</span>
              <span id="fullTotalTime">0:00</span>
            </div>
          </div>
        </div>
      </div>

      <div class="lyrics-container" id="lyricsContainer">
        <div class="lyrics-line">Choose a song to see lyrics</div>
      </div>

      <div class="artist-info-container">
        <img src="" alt="Artist" class="artist-image" id="artistImage">
        <div class="artist-details">
          <div class="artist-name" id="artistName">Artist Name</div>
          <div class="artist-year" id="artistYear">Year: -</div>
          <div class="artist-genre" id="artistGenre">Genre: -</div>
        </div>
      </div>

      <div class="artist-overview-container">
        <div class="artist-overview-header">
          <h3>Artist Overview</h3>
        </div>

        <div class="artist-description">
          <h4>About</h4>
          <p id="artistDescription">Loading artist details...</p>
        </div>

        <div class="artist-stats">
          <div class="stat-card">
            <span class="material-icons">group</span>
            <div class="stat-value" id="artistSubscribers">-</div>
            <div class="stat-label">Subscribers</div>
          </div>
          <div class="stat-card">
            <span class="material-icons">visibility</span>
            <div class="stat-value" id="artistViews">-</div>
            <div class="stat-label">Total Views</div>
          </div>
          <div class="stat-card">
            <span class="material-icons">headphones</span>
            <div class="stat-value" id="artistMonthlyListeners">-</div>
            <div class="stat-label">Monthly Listeners</div>
          </div>
        </div>

        <div class="artist-top-songs">
          <h4>Popular Songs</h4>
          <div class="top-songs-list" id="topSongsList">
            <!-- Songs will be populated here -->
          </div>
        </div>

        <div class="artist-links" id="artistLinks">
          <!-- Links will be added here -->
        </div>
      </div>
    </div>

    <!-- Integration Container Section -->
    <div class="integration-container" id="integrationContainer" style="display: none;">
      <div class="integration-header">
        <h3 class="text-lg font-bold mb-4">Integrate this Song</h3>
        <button class="close-button" id="closeIntegration">
          <span class="material-icons">close</span>
        </button>
      </div>

      <div class="integration-options">
        <div class="integration-sizes">
          <label class="text-sm text-gray-300 mb-2">Choose Size:</label>
          <div class="size-buttons">
            <button class="size-btn active" data-size="small">Small</button>
            <button class="size-btn" data-size="normal">Normal</button>
            <button class="size-btn" data-size="large">Large</button>
          </div>
        </div>

        <div class="integration-themes">
          <label class="text-sm text-gray-300 mb-2">Choose Theme:</label>
          <div class="theme-buttons">
            <button class="theme-btn active" data-theme="default">
              <span class="theme-color default"></span>
              Default
            </button>
            <button class="theme-btn" data-theme="purple">
              <span class="theme-color purple"></span>
              Purple
            </button>
            <button class="theme-btn" data-theme="blue">
              <span class="theme-color blue"></span>
              Blue
            </button>
            <button class="theme-btn" data-theme="dark">
              <span class="theme-color dark"></span>
              Dark
            </button>
          </div>
        </div>

        <div class="integration-preview">
          <label class="text-sm text-gray-300 mb-2">Preview:</label>
          <div class="preview-container" id="previewContainer">
            <iframe id="previewFrame" frameborder="0" allowtransparency="true" allow="encrypted-media"></iframe>
          </div>
        </div>



        <div class="integration-code">
          <label class="text-sm text-gray-300 mb-2">Embed Code:</label>
          <div class="code-container">
            <pre id="embedCode" class="code-block"></pre>
            <button class="copy-btn" id="copyCode">
              <span class="material-icons">content_copy</span>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- History Modal Section -->
  <div id="historyModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Listening History</h2>
        <button class="close-button" id="closeHistory">
          <span class="material-icons">close</span>
        </button>
      </div>
      <div class="modal-body">
        <div id="historyList" class="history-list"></div>
      </div>
    </div>
  </div>
  <!-- Playlist Modal Section -->
  <div id="playlistModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Playlists</h2>
        <button class="close-button" id="closePlaylist">
          <span class="material-icons">close</span>
        </button>
      </div>
      <div class="modal-body">
        <div class="playlist-actions">
          <button id="createPlaylistBtn" class="glass-button">Create New Playlist</button>
        </div>
        <div id="playlistList" class="playlist-list"></div>
      </div>
    </div>
  </div>

  <!-- Hidden Audio Element -->
  <audio id="audioElement" preload="auto"></audio>


  <script>


    /**
     * Global state management
     * Handles all dynamic data for the player including:
     * - Current playback state
     * - Queue management
     * - Search state
     * - Volume settings
     */
    const state = {
      currentSongId: null,        // Currently playing/selected song ID
      recommendationsLoading: false, // Flag for recommendation loading state
      maxQueueSize: 50,          // Maximum songs in queue
      isPlaying: false,          // Current playback state
      queue: [],                 // Song queue array
      queueIndex: -1,            // Current position in queue
      volume: localStorage.getItem("player-volume") || 100, // Playback volume (0-100)
      searchQuery: "",           // Current search query
      searchPage: 0,             // Current page for infinite scroll
      searchLimit: 20,           // Items per page
      searchHasMore: true,       // Flag for more results available
      loadingMore: false,        // Flag for loading state
      displayedItems: new Set()  // Track displayed songs to prevent duplicates
    };

    /**
     * DOM Elements
     * Centralized access to all DOM elements used by the player
     * Grouped by functionality for better organization
     */
    const E = {
      // Search Related Elements
      searchInput: document.getElementById("searchInput"),
      broomIcon: document.getElementById("broomIcon"),
      micIcon: document.getElementById("micIcon"),
      resultsContainer: document.getElementById("resultsContainer"),
      infiniteLoader: document.getElementById("infiniteLoader"),

      // Mini Player Elements
      miniPlayer: document.getElementById("miniPlayer"),
      miniPlayerThumb: document.getElementById("miniPlayerThumb"),
      miniPlayerTitle: document.getElementById("miniPlayerTitle"),
      miniPlayerArtist: document.getElementById("miniPlayerArtist"),
      playButton: document.getElementById("playButton"),
      prevButton: document.getElementById("prevButton"),
      nextButton: document.getElementById("nextButton"),

      // Progress Elements
      progressBar: document.getElementById("progressBar"),
      progressSkeleton: document.getElementById("progressSkeleton"),
      progressContainer: document.getElementById("progressContainer"),
      progressHover: document.getElementById("progressHover"),
      currentTime: document.getElementById("currentTime"),
      totalTime: document.getElementById("totalTime"),

      // Volume Elements
      volumeSlider: document.getElementById("volumeSlider"),
      volumeButton: document.getElementById("volumeButton"),

      // Full Player Elements
      expandButton: document.getElementById("expandButton"),
      minimizeButton: document.getElementById("minimizeButton"),
      fullPlayer: document.getElementById("fullPlayer"),
      fullPlayerArt: document.getElementById("fullPlayerArt"),
      fullPlayerTitle: document.getElementById("fullPlayerTitle"),
      fullPlayerArtist: document.getElementById("fullPlayerArtist"),

      // Content Elements
      lyricsContainer: document.getElementById("lyricsContainer"),
      artistImage: document.getElementById("artistImage"),
      artistName: document.getElementById("artistName"),
      artistYear: document.getElementById("artistYear"),
      artistGenre: document.getElementById("artistGenre"),

      // Full Player Controls
      fullPlayButton: document.getElementById("fullPlayButton"),
      fullPrevButton: document.getElementById("fullPrevButton"),
      fullNextButton: document.getElementById("fullNextButton"),
      fullProgressBar: document.getElementById("fullProgressBar"),
      fullProgressContainer: document.getElementById("fullProgressContainer"),
      fullProgressHover: document.getElementById("fullProgressHover"),
      fullCurrentTime: document.getElementById("fullCurrentTime"),
      fullTotalTime: document.getElementById("fullTotalTime"),

      // Audio Element
      audio: document.getElementById("audioElement")
    };

    /**
     * Core Utility Functions
     * Basic helper functions used throughout the application
     */

    /**
     * Format time in seconds to MM:SS format
     * @param {number} sec - Time in seconds
     * @returns {string} Formatted time string
     */


    /**
     * Debounce function for search input
     * @param {Function} fn - Function to debounce
     * @param {number} delay - Delay in milliseconds
     */
    function debounce(fn, delay) {
      let t;
      return (...args) => {
        clearTimeout(t);
        t = setTimeout(() => fn(...args), delay);
      };
    }

    /**
     * Show toast notification
     * @param {string} message - Message to display
     */
    function showToast(message, type = 'info') {
      // const toast = document.createElement('div');
      // toast.className = 'toast-notification';
      // toast.textContent = message;
      // document.body.appendChild(toast);
      // setTimeout(() => toast.remove(), 3000);
      showNotification(type, 'Sangeet Premium', message, 4000);
    }

    /**
     * Initial styles setup
     * Add required styles for toast notifications and controls
     */
    const additionalStyles = document.createElement('style');
    additionalStyles.textContent = `
  .toast-notification {
    position: fixed;
    bottom: 100px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 12px 24px;
    border-radius: 24px;
    font-size: 14px;
    z-index: 1000;
    animation: toastIn 0.3s ease, toastOut 0.3s ease 2.7s forwards;
  }

  @keyframes toastIn {
    from { opacity: 0; transform: translate(-50%, 20px); }
    to { opacity: 1; transform: translate(-50%, 0); }
  }

  @keyframes toastOut {
    from { opacity: 1; transform: translate(-50%, 0); }
    to { opacity: 0; transform: translate(-50%, 20px); }
  }

  .additional-controls {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    border-left: 1px solid rgba(255,255,255,0.1);
    padding-left: 1rem;
    margin-left: 0.5rem;
  }

  .full-player .additional-controls {
    border: none;
    padding-left: 0;
    margin-left: 1rem;
  }

  @media (max-width: 768px) {
    .additional-controls {
      border: none;
      padding-left: 0;
    }
  }
`;
    document.head.appendChild(additionalStyles);
    /**
     * Enhanced Music Player - Complete JavaScript Implementation
     * =======================================================
     *
     * PART 2: Speech Recognition & Player Controls
     */

    /**
     * Speech Recognition Setup
     * Handles voice search functionality
     */
     const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
const recognition = SpeechRecognition ? new SpeechRecognition() : null;

function setupSpeechRecognition() {
  if (!recognition) {
    E.micIcon.style.display = 'none';
    return;
  }

  recognition.continuous = false;
  recognition.interimResults = false;
  recognition.lang = 'en-US';

  let isListening = false;
  let wasPlaying = false; // Tracks if audio was playing before STT

  function startListening() {
    try {
      isListening = true;
      E.micIcon.textContent = 'mic';
      E.micIcon.classList.add('listening');
      E.micIcon.style.color = 'var(--primary-light)';
      E.searchInput.placeholder = 'Listening...';

      // Pause audio if it’s playing
      if (E.audio && !E.audio.paused) {
        wasPlaying = true;
        E.audio.pause();
      } else {
        wasPlaying = false;
      }

      recognition.start();
    } catch (err) {
      console.error('Speech recognition start error:', err);
      stopListening();
    }
  }

  function stopListening() {
    isListening = false;
    E.micIcon.classList.remove('listening');
    E.micIcon.style.color = '';
    E.micIcon.textContent = 'mic';
    E.searchInput.placeholder = 'Search for songs or tap mic to speak...';

    // Resume audio if it was playing
    if (wasPlaying && E.audio.paused) {
      E.audio.play().catch(error => {
        console.error('Error resuming playback:', error);
        showToast('Failed to resume playback', 'error');
      });
    }
    wasPlaying = false; // Reset the flag

    try {
      recognition.stop();
    } catch (err) {
      console.error('Speech recognition stop error:', err);
    }
  }

  // Speech Recognition Event Handlers
  recognition.onstart = () => {
    isListening = true;
    E.micIcon.textContent = 'mic';
    E.micIcon.classList.add('listening');
  };

  recognition.onend = () => {
    stopListening();
  };

  recognition.onresult = (event) => {
    const transcript = event.results[0][0].transcript;
    E.searchInput.value = transcript;
    E.searchInput.dispatchEvent(new Event('input'));

    E.micIcon.textContent = 'done';
    setTimeout(() => {
      E.micIcon.textContent = 'mic';
    }, 1000);
  };

  recognition.onerror = (event) => {
    console.error('Speech recognition error:', event.error);
    E.micIcon.textContent = 'mic_off';
    let errorMessage;
    switch (event.error) {
      case 'network':
        errorMessage = 'Network error: Please check your internet connection.';
        break;
      case 'no-speech':
        errorMessage = 'No speech detected. Please try again.';
        break;
      case 'not-allowed':
        errorMessage = 'Permission denied. Ensure the page is served over HTTPS or localhost.';
        break;
      default:
        errorMessage = 'An error occurred during speech recognition.';
    }
    showToast(errorMessage, 'error');
    setTimeout(() => {
      stopListening();
    }, 1000);
  };

  // Mic Icon Event Listeners
  E.micIcon.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();
    isListening ? stopListening() : startListening();
  });

  E.micIcon.addEventListener('touchend', (e) => {
    e.preventDefault();
    e.stopPropagation();
    isListening ? stopListening() : startListening();
  });
}

    /**
     * Player Controls Setup
     * Handles all player control buttons and functionality
     */

    // Define control button templates
    const additionalControls = `
<div class="additional-controls">
  <button class="control-button" id="downloadButton" title="Download song">
    <span class="material-icons">download</span>
  </button>
  <button class="control-button" id="shareButton" title="Share song">
    <span class="material-icons">share</span>
  </button>
</div>
`;

    const fullPlayerControls = `
<div class="additional-controls">
  <button class="control-button" id="fullDownloadButton" title="Download song">
    <span class="material-icons">download</span>
  </button>
  <button class="control-button" id="fullShareButton" title="Share song">
    <span class="material-icons">share</span>
  </button>
</div>
`;

    /**
     * Initialize Player Controls
     * Sets up all control buttons and their event handlers
     */
    function initializePlayerControls() {
      // Add controls to players
      document.querySelector('.volume-control').insertAdjacentHTML('afterend', additionalControls);
      document.querySelector('.full-player .player-controls').insertAdjacentHTML('beforeend', fullPlayerControls);



      const controls = {
        share: {
          mini: document.getElementById('shareButton'),
          full: document.getElementById('fullShareButton')
        },
        download: {
          mini: document.getElementById('downloadButton'),
          full: document.getElementById('fullDownloadButton')
        }
      };

      /**
       * Handle song sharing
       * Provides native share or fallback to clipboard copy
       */
      async function handleShare() {
        if (!state.currentSongId) return;

        const shareUrl = `${window.location.origin}/share/open/${state.currentSongId}`;
        const songTitle = `${E.miniPlayerTitle.textContent} - ${E.miniPlayerArtist.textContent}`;

        try {
          if (navigator.share) {
            await navigator.share({
              title: songTitle,
              text: 'Check out this song!',
              url: shareUrl
            });
          } else {
            await navigator.clipboard.writeText(shareUrl);
            Object.values(controls.share).forEach(btn => {
              if (btn) {
                const icon = btn.querySelector('.material-icons');
                icon.textContent = 'check';
                setTimeout(() => icon.textContent = 'share', 2000);
              }
            });
            showToast('Share link copied to clipboard!');
          }
        } catch (err) {
          console.error('Share failed:', err);
        }
      }

      /**
       * Handle song download
       * Downloads current song and shows feedback
       */
      async function handleDownload() {
        if (!state.currentSongId) return;

        try {
          // Update button states
          Object.values(controls.download).forEach(btn => {
            if (btn) {
              const icon = btn.querySelector('.material-icons');
              icon.textContent = 'cloud_download';
            }
          });

          // Trigger download
          const link = document.createElement('a');
          link.href = `/api/download/${state.currentSongId}`;
          link.style.display = 'none';
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);

          // Show success
          Object.values(controls.download).forEach(btn => {
            if (btn) {
              const icon = btn.querySelector('.material-icons');
              icon.textContent = 'cloud_done';
              setTimeout(() => icon.textContent = 'download', 2000);
            }
          });

        } catch (error) {
          console.error('Download error:', error);
          // Show error
          Object.values(controls.download).forEach(btn => {
            if (btn) {
              const icon = btn.querySelector('.material-icons');
              icon.textContent = 'cloud_off';
              setTimeout(() => icon.textContent = 'download', 2000);
            }
          });
          showToast('Download failed. Please try again.');
        }
      }

      // Attach event listeners to all controls
      Object.values(controls.share).forEach(btn => {
        btn?.addEventListener('click', handleShare);
      });

      Object.values(controls.download).forEach(btn => {
        btn?.addEventListener('click', handleDownload);
      });
    }

    /**
     * Volume Control Functions
     * Handles volume slider and mute functionality
     */
    function handleVolumeChange(e) {
      state.volume = e.target.value;
      localStorage.setItem("player-volume", state.volume);
      E.audio.volume = state.volume / 100;
      updateVolumeIcon(state.volume);
    }

    function toggleMute() {
      if (E.audio.volume > 0) {
        E.volumeSlider.dataset.lastVol = state.volume;
        E.volumeSlider.value = 0;
        state.volume = 0;
      } else {
        const lastVol = E.volumeSlider.dataset.lastVol || 100;
        E.volumeSlider.value = lastVol;
        state.volume = lastVol;
      }
      E.volumeSlider.dispatchEvent(new Event("input"));
    }

    function updateVolumeIcon(volume) {
      const icon = E.volumeButton.querySelector(".material-icons");
      if (volume == 0) icon.textContent = "volume_off";
      else if (volume < 50) icon.textContent = "volume_down";
      else icon.textContent = "volume_up";
    }
    /**
     * Enhanced Music Player - Complete JavaScript Implementation
     * =======================================================
     *
     * PART 3: Media Playback & Progress Tracking
     */

    /**
     * Progress Bar Setup
     * Handles progress bar interaction and display
     */
    function setupProgressBar(container, progressHover, callback) {
      if (!container || !progressHover) return;

      let isDragging = false;

      container.addEventListener("mousemove", (e) => {
        const rect = container.getBoundingClientRect();
        const percent = ((e.clientX - rect.left) / rect.width) * 100;
        progressHover.style.width = `${percent}%`;

        if (isDragging && E.audio.duration) {
          E.audio.currentTime = E.audio.duration * (percent / 100);
        }
      });

      container.addEventListener("mouseleave", () => {
        progressHover.style.width = "0%";
      });

      container.addEventListener("mousedown", () => {
        isDragging = true;
      });

      document.addEventListener("mouseup", () => {
        isDragging = false;
      });

      container.addEventListener("click", (e) => {
        const rect = container.getBoundingClientRect();
        const percent = (e.clientX - rect.left) / rect.width;
        if (E.audio.duration) {
          E.audio.currentTime = E.audio.duration * percent;
          if (callback) callback(percent);
        }
      });

      // Touch support
      container.addEventListener("touchstart", (e) => {
        e.preventDefault();
        isDragging = true;
      });

      container.addEventListener("touchmove", (e) => {
        if (!isDragging) return;
        const touch = e.touches[0];
        const rect = container.getBoundingClientRect();
        const percent = ((touch.clientX - rect.left) / rect.width) * 100;
        progressHover.style.width = `${percent}%`;

        if (E.audio.duration) {
          E.audio.currentTime = E.audio.duration * (percent / 100);
        }
      });

      container.addEventListener("touchend", () => {
        isDragging = false;
      });
    }


    /**
     * Toggle play/pause state
     */
    // Add these functions to your JavaScript where you handle audio playback

    // Track loading state
    let isAudioLoading = false;
    let playAfterLoad = false;

    // Enhanced audio initialization
    function initializeAudio() {
      const audioElement = document.getElementById('audioElement');

      // Loading states
      audioElement.addEventListener('loadstart', () => {
        isAudioLoading = true;
        console.log('Audio loading started');
      });

      audioElement.addEventListener('canplay', () => {
        isAudioLoading = false;
        console.log('Audio can play');
        if (playAfterLoad) {
          playAfterLoad = false;
          playAudioSafely();
        }
      });

      // Error handling
      audioElement.addEventListener('error', (e) => {
        isAudioLoading = false;
        playAfterLoad = false;
        console.error('Audio error:', e);
      });

      // Abort handling
      audioElement.addEventListener('abort', () => {
        isAudioLoading = false;
        playAfterLoad = false;
        console.log('Audio loading aborted');
      });
    }


    async function loadAndPlay(songId) {
      if (songId === state.currentSongId) {
        togglePlay();
        return;
      }

      state.currentSongId = songId;
      E.miniPlayer.classList.remove("hidden");

      // Reset UI placeholders
      resetPlayerUI();
      E.progressSkeleton.style.opacity = "1";

      try {
        // Reset states
        isAudioLoading = true;
        playAfterLoad = true;

        // Get song info and stream URL in parallel
        const [infoData, streamData] = await Promise.all([
          fetch(`/api/song-info/${songId}`).then(r => r.json()),
          fetch(`/api/stream/${songId}`).then(r => r.json())
        ]);

        if (infoData.error) throw new Error(infoData.error);
        if (streamData.error) throw new Error(streamData.error);

        // Start new listening session
        const sessionResponse = await fetch('/api/listen/start', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            songId: songId,
            title: infoData.title,
            artist: infoData.artist
          })
        });

        const sessionData = await sessionResponse.json();
        currentListenId = sessionData.listenId;

        // Update audio source
        E.audio.src = streamData.url;
        await E.audio.load();  // Ensure audio is loaded

        // Update both mini and full player info
        updatePlayerInfo(infoData);

        // Load additional content
        loadLyrics(songId);
        loadArtistInfo(infoData.artist);

        // Attempt to play safely
        await playAudioSafely();
        updatePlayPauseUI(true);
        syncProgress();

      } catch (e) {
        console.error("loadAndPlay error:", e);
        resetPlayerUI();
        showToast("Failed to load song. Please try again.");
      } finally {
        isAudioLoading = false;
      }
    }

    // Add this safe play function
    async function playAudioSafely() {
      try {
        if (isAudioLoading) {
          playAfterLoad = true;
          return;
        }

        if (E.audio.readyState >= 2) { // HAVE_CURRENT_DATA or better
          await E.audio.play();
        } else {
          playAfterLoad = true;
          E.audio.addEventListener('canplay', () => {
            if (playAfterLoad) {
              playAfterLoad = false;
              E.audio.play().catch(console.error);
            }
          }, { once: true });
        }
      } catch (error) {
        console.error('Play error:', error);
        if (error.name === 'AbortError') {
          // Try again after a short delay
          setTimeout(playAudioSafely, 100);
        }
      }
    }

    // Update the togglePlay function to use safe play
    function togglePlay() {
      if (!state.currentSongId) return;

      if (E.audio.paused) {
        playAudioSafely()
          .then(() => {
            updatePlayPauseUI(true);
          })
          .catch(err => {
            console.error("Play failed:", err);
            showToast("Playback failed. Please try again.");
          });
      } else {
        E.audio.pause();
        updatePlayPauseUI(false);
      }
    }

    // Add these event listeners to your audio element initialization
    E.audio.addEventListener('loadstart', () => {
      isAudioLoading = true;
      E.progressSkeleton.style.opacity = "1";  // Keep original loading indicator
    });

    E.audio.addEventListener('canplay', () => {
      isAudioLoading = false;
      E.progressSkeleton.style.opacity = "0";  // Keep original loading indicator
      if (playAfterLoad) {
        playAfterLoad = false;
        playAudioSafely();
      }
    });

    E.audio.addEventListener('error', () => {
      isAudioLoading = false;
      playAfterLoad = false;
      E.progressSkeleton.style.opacity = "0";
    });
    // Initialize when page loads
    document.addEventListener('DOMContentLoaded', initializeAudio);
    /**
     * Update play/pause UI elements
     * @param {boolean} isPlaying - Current playing state
     */
    function updatePlayPauseUI(isPlaying) {
      const miniIcon = E.playButton.querySelector(".material-icons");
      const fullIcon = E.fullPlayButton.querySelector(".material-icons");

      miniIcon.textContent = isPlaying ? "pause_circle" : "play_circle";
      fullIcon.textContent = isPlaying ? "pause" : "play_arrow";

      state.isPlaying = isPlaying;

      if (isPlaying) {
        requestAnimationFrame(syncProgress);
      }
    }

    /**
     * Sync progress between mini and full player
     */
    function syncProgress() {
      if (E.audio.paused) return;

      const current = E.audio.currentTime;
      const duration = E.audio.duration;

      if (duration > 0) {
        const percent = (current / duration) * 100;
        E.progressBar.style.width = `${percent}%`;
        E.fullProgressBar.style.width = `${percent}%`;
      }

      E.currentTime.textContent = formatTime(current);
      E.fullCurrentTime.textContent = formatTime(current);
      E.totalTime.textContent = formatTime(duration);
      E.fullTotalTime.textContent = formatTime(duration);

      requestAnimationFrame(syncProgress);
    }

    /**
     * Reset player UI to loading state
     */
    function resetPlayerUI() {
      E.fullPlayerTitle.innerHTML = "<span>Loading...</span>";
      E.fullPlayerArtist.textContent = "Buffering...";
      E.fullPlayerArt.src = "/static/images/loading.png";
      E.lyricsContainer.innerHTML = '<div class="lyrics-line">Loading lyrics...</div>';
      E.artistImage.src = "";
      E.artistName.textContent = "Loading...";
      E.artistYear.textContent = "Year: -";
      E.artistGenre.textContent = "Genre: -";
      E.progressSkeleton.style.opacity = "1";
    }

    /**
     * Update player info with song details
     * @param {Object} info - Song information
     */
    function updatePlayerInfo(info) {
      // Update mini player
      E.miniPlayerThumb.src = info.thumbnail || '/static/images/default-cover.png';
      E.miniPlayerTitle.textContent = info.title || 'Unknown Title';
      E.miniPlayerArtist.textContent = info.artist || 'Unknown Artist';

      // Update full player
      E.fullPlayerArt.src = info.thumbnail || '/static/images/default-cover.png';
      E.fullPlayerTitle.innerHTML = `<span>${info.title || 'Unknown Title'}</span>`;
      E.fullPlayerArtist.textContent = info.artist || 'Unknown Artist';




      // Update document title
      document.title = `${info.title} - ${info.artist} | Music Player`;
      if ('mediaSession' in navigator) {
        navigator.mediaSession.metadata = new MediaMetadata({
          title: info.title || 'Unknown Title',
          artist: info.artist || 'Unknown Artist',
          artwork: [
            { src: info.thumbnail || '/static/images/default-cover.png', sizes: '512x512', type: 'image/jpg' }
          ]
        });
      }
    }

    /**
     * Show play hint for autoplay restriction
     */
    function showPlayHint() {
      const hint = document.createElement('div');
      hint.style.cssText = `
    position: fixed;
    bottom: 120px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--accent-gradient);
    color: white;
    padding: 12px 24px;
    border-radius: 24px;
    font-size: 14px;
    z-index: 1000;
    animation: playHintPulse 2s infinite;
  `;
      hint.textContent = '👆 Click play to start listening';
      document.body.appendChild(hint);

      const removeHint = () => {
        hint.style.animation = 'toastOut 0.3s ease forwards';
        setTimeout(() => hint.remove(), 300);
      };

      document.addEventListener('click', removeHint, { once: true });
      setTimeout(removeHint, 5000);
    }

    /**
     * Audio Element Event Listeners
     */
    function setupAudioEventListeners() {
      E.audio.addEventListener("loadedmetadata", () => {
        E.totalTime.textContent = formatTime(E.audio.duration);
        E.fullTotalTime.textContent = formatTime(E.audio.duration);
        E.progressSkeleton.style.opacity = "0";
      });

      E.audio.addEventListener("playing", () => {
        state.isPlaying = true;
        updatePlayPauseUI(true);
      });

      E.audio.addEventListener("pause", () => {
        state.isPlaying = false;
        updatePlayPauseUI(false);
      });

      E.audio.addEventListener("ended", async () => {
        // End current listening session
        await endListeningSession(
          Math.round(E.audio.duration),
          Math.round(E.audio.currentTime)
        );

        state.isPlaying = false;
        updatePlayPauseUI(false);
        playNext();
      });

      // Add handler for when user stops/changes song
      E.audio.addEventListener("pause", async () => {
        if (currentListenId) {
          await endListeningSession(
            Math.round(E.audio.duration),
            Math.round(E.audio.currentTime)
          );
        }
      });

      E.audio.addEventListener("error", (e) => {
        console.error("Audio error:", e);
        showToast("Error playing audio. Please try again.");
      });
    }

    /**
     * Enhanced Music Player - Complete JavaScript Implementation
     * =======================================================
     *
     * PART 4: Queue Management & Search Functionality
     */

    /**
     * Queue Management Functions
     * Handles song queue and playback sequence
     */

    /**
     * Add song to queue and play
     * @param {string} songId - ID of song to queue and play
     */
    async function queueAndPlaySong(songId) {
      // Reset queue if it's too large
      if (state.queue.length > state.maxQueueSize) {
        state.queue = [];
        state.queueIndex = -1;
      }

      addToQueue(songId);
      state.queueIndex = state.queue.indexOf(songId);

      await loadAndPlay(songId);

      // Preload recommendations
      try {
        const response = await fetch(`/api/get-recommendations/${songId}`);
        const recommendations = await response.json();

        if (Array.isArray(recommendations)) {
          recommendations.forEach(song => {
            if (!state.queue.includes(song.id)) {
              state.queue.push(song.id);
            }
          });
        }
      } catch (error) {
        console.error("Error prefetching recommendations:", error);
      }
    }

    /**
     * Add song to queue
     * @param {string} songId - ID of song to add
     */
    function addToQueue(songId) {
      if (!state.queue.includes(songId)) {
        state.queue.push(songId);
      }
    }

    /**
     * Play next song in queue
     */
    async function playNext() {
      if (!state.currentSongId) return;

      // Try queue first
      if (state.queueIndex < state.queue.length - 1) {
        state.queueIndex++;
        await loadAndPlay(state.queue[state.queueIndex]);
        return;
      }

      try {
        const response = await fetch(`/api/play-sequence/${state.currentSongId}/next`);
        const data = await response.json();

        if (response.status === 404) {
          return; // No next song
        }

        if (data.error) {
          console.warn("Next song error:", data.error);
          return;
        }

        // Handle both single song and recommendations array
        const nextSongs = Array.isArray(data) ? data : [data];

        // Add new songs to queue
        nextSongs.forEach(song => {
          if (!state.queue.includes(song.id)) {
            state.queue.push(song.id);
          }
        });

        const nextSongId = nextSongs[0].id;
        state.queueIndex = state.queue.indexOf(nextSongId);
        await loadAndPlay(nextSongId);

      } catch (error) {
        console.error("Error playing next:", error);
        showToast("Failed to play next song");
      }
    }

    /**
     * Play previous song in queue
     */
    async function playPrevious() {
      if (!state.currentSongId) return;

      // Try queue first
      if (state.queueIndex > 0) {
        state.queueIndex--;
        await loadAndPlay(state.queue[state.queueIndex]);
        return;
      }

      try {
        const response = await fetch(`/api/play-sequence/${state.currentSongId}/previous`);
        const data = await response.json();

        if (response.status === 404) {
          // If no previous song, restart current song if played for a while
          if (E.audio.currentTime > 3) {
            E.audio.currentTime = 0;
          }
          return;
        }

        if (data.error) {
          if (E.audio.currentTime > 3) {
            E.audio.currentTime = 0;
          }
          return;
        }

        // Add to queue if not exists
        if (!state.queue.includes(data.id)) {
          state.queue.splice(state.queueIndex, 0, data.id);
        }

        state.queueIndex = state.queue.indexOf(data.id);
        await loadAndPlay(data.id);

      } catch (error) {
        console.error("Error playing previous:", error);
        if (E.audio.currentTime > 3) {
          E.audio.currentTime = 0;
        }
      }
    }

    /**
     * Search Functionality
     * Handles search and results display
     */

    /**
     * Load search results with deduplication
     * @param {boolean} reset - Whether to reset search state
     */
    async function loadSearchResults(reset = false) {
      if (reset) {
        state.searchPage = 0;
        state.searchHasMore = true;
        E.resultsContainer.innerHTML = "";
        state.displayedItems.clear();
      }

      if (!state.searchHasMore || state.loadingMore) return;

      state.loadingMore = true;
      E.infiniteLoader.style.display = "block";

      if (state.searchPage === 0) {
        showSkeleton();
      }

      try {
        const q = encodeURIComponent(state.searchQuery);
        const page = state.searchPage;
        const limit = state.searchLimit;
        const res = await fetch(`/api/search?q=${q}&page=${page}&limit=${limit}`);
        const newResults = await res.json();

        if (state.searchPage === 0) {
          E.resultsContainer.innerHTML = ""; // Clear only on reset
        }

        if (!Array.isArray(newResults) || newResults.length === 0) {
          state.searchHasMore = false;
          if (state.searchPage === 0) {
            E.resultsContainer.innerHTML = "<p>No results found.</p>";
          }
        } else {
          // Create a set of new result IDs for comparison
          const newIds = new Set(newResults.map(song => song.id));

          // Remove results no longer in the new list (only if not resetting)
          if (!reset) {
            const currentItems = E.resultsContainer.querySelectorAll('.result-item');
            currentItems.forEach(item => {
              const songId = item.dataset.id;
              if (!newIds.has(songId) && state.displayedItems.has(songId)) {
                item.remove();
                state.displayedItems.delete(songId);
              }
            });
          }

          // Append only new, unique results
          newResults.forEach(song => {
            if (!state.displayedItems.has(song.id)) {
              displayResults([song]); // Pass single song as array
              state.displayedItems.add(song.id);
            }
          });

          // Update pagination
          state.searchPage += 1;
          state.searchHasMore = newResults.length === state.searchLimit;
        }
      } catch (error) {
        console.error("Error loading search results:", error);
        showToast("Failed to load results. Please try again.", "error");
      } finally {
        state.loadingMore = false;
        E.infiniteLoader.style.display = "none";
      }
    }
    /**
     * Display search results
     * @param {Array} items - Array of song items to display
     */
    function displayResults(items) {
      const uniqueItems = items.filter(song => {
        const key = `${song.id}-${song.title}-${song.artist}`.toLowerCase();
        if (state.displayedItems.has(song.id) || state.displayedItems.has(key)) {
          return false;
        }
        state.displayedItems.add(song.id);
        state.displayedItems.add(key);
        return true;
      });

      if (uniqueItems.length === 0) return;

      const html = uniqueItems.map(song => `
    <div class="song-card" data-id="${song.id}">
      <div class="song-thumbnail-container">
        <img class="song-thumbnail"
             loading="lazy"
             src="${song.thumbnail || "/static/images/default-cover.png"}"
             alt="${song.title}">
        <div class="song-duration">${formatTime(song.duration)}</div>
      </div>
      <div class="song-info">
        <div class="song-title">${song.title}</div>
        <div class="song-artist">${song.artist}</div>
      </div>
    </div>
  `).join("");

      E.resultsContainer.insertAdjacentHTML("beforeend", html);

      // Add click handlers
      document.querySelectorAll(".song-card").forEach(card => {
        if (!card.hasListener) {
          card.hasListener = true;
          card.addEventListener("click", () => {
            const sid = card.dataset.id;
            queueAndPlaySong(sid);
          });
        }
      });
    }

    /**
     * Show skeleton loading animation
     */
    function showSkeleton() {
      E.resultsContainer.innerHTML = Array(6).fill("")
        .map(() => `<div class="song-card skeleton"></div>`)
        .join("");
    }

    /**
     * Check if item is already displayed
     * @param {Object} item - Song item to check
     * @returns {boolean} Whether item is already displayed
     */
    // Enhanced isItemDisplayed function with better duplicate detection
    function isItemDisplayed(item) {
      // Create a unique signature for the item that considers multiple factors
      const signatures = [
        // Basic ID check
        item.id,

        // Title + Artist normalized signature
        `${item.title}-${item.artist}`.toLowerCase().trim(),

        // Title-only normalized signature (for covers/remixes)
        item.title.toLowerCase().trim(),

        // Clean-text signature (removes special characters)
        `${item.title}-${item.artist}`
          .toLowerCase()
          .replace(/[^\w\s-]/g, '')
          .trim()
      ];

      // Check if any signature exists in our tracking set
      return signatures.some(sig => state.displayedItems.has(sig));
    }

    // Enhanced displayResults function with improved deduplication
    function displayResults(items) {
      const uniqueItems = items.filter(song => {
        if (isItemDisplayed(song)) {
          return false;
        }

        // Add all signatures to tracking set
        const signatures = [
          song.id,
          `${song.title}-${song.artist}`.toLowerCase().trim(),
          song.title.toLowerCase().trim(),
          `${song.title}-${song.artist}`
            .toLowerCase()
            .replace(/[^\w\s-]/g, '')
            .trim()
        ];

        signatures.forEach(sig => state.displayedItems.add(sig));
        return true;
      });

      // Rest of the display logic...
      if (uniqueItems.length === 0) return;

      const html = uniqueItems.map(song => `
    <div class="song-card" data-id="${song.id}">
      <div class="song-thumbnail-container">
        <img class="song-thumbnail"
             loading="lazy"
             src="${song.thumbnail || "/static/images/default-cover.png"}"
             alt="${song.title}">
        <div class="song-duration">${formatTime(song.duration)}</div>
      </div>
      <div class="song-info">
        <div class="song-title">${song.title}</div>
        <div class="song-artist">${song.artist}</div>
      </div>
    </div>
  `).join("");

      E.resultsContainer.insertAdjacentHTML("beforeend", html);

      // Add click handlers
      document.querySelectorAll(".song-card").forEach(card => {
        if (!card.hasListener) {
          card.hasListener = true;
          card.addEventListener("click", () => {
            const sid = card.dataset.id;
            queueAndPlaySong(sid);
          });
        }
      });
    }

    // Reset function to clear tracking when starting new search
    function resetSearchState() {
      state.searchPage = 0;
      state.searchHasMore = true;
      E.resultsContainer.innerHTML = "";
      state.displayedItems.clear();
    }

    // Debounced search function
    const doSearch = debounce(() => {
      state.searchQuery = E.searchInput.value.trim();
      loadSearchResults(true);
    }, 400);

    // Search input handler
    E.searchInput.addEventListener("input", () => {
      if (E.searchInput.value.trim()) {
        E.broomIcon.style.display = "block";
      } else {
        E.broomIcon.style.display = "none";
        state.displayedItems.clear();
      }
      doSearch();
    });

    // Clear search handler
    E.broomIcon.addEventListener("click", () => {
      E.searchInput.value = "";
      E.broomIcon.style.display = "none";
      state.displayedItems.clear();
      doSearch();
    });
    /**
     * Enhanced Music Player - Complete JavaScript Implementation
     * =======================================================
     *
     * PART 5: Initialization and Event Bindings
     */

    /**
     * Setup all event listeners
     * Initializes all event handlers for the application
     */
    function setupEventListeners() {
      // Keyboard shortcuts
      document.addEventListener("keydown", e => {
        // if (e.code === "Space" && e.target === document.body) {
        //   e.preventDefault();
        //   togglePlay();
        // }
        if (e.code === "Space" && e.target !== E.searchInput) {
          e.preventDefault();
          togglePlay();
        }
        if ((e.code === "ArrowLeft" || e.key === ",") && (e.ctrlKey || e.shiftKey)) {
          e.preventDefault();
          playPrevious();
        }
        if ((e.code === "ArrowRight" || e.key === ".") && (e.ctrlKey || e.shiftKey)) {
          e.preventDefault();
          playNext();
        }
        if (e.code === "Escape") {
          E.fullPlayer.classList.remove("active");
        }
      });

      // Mini player controls
      E.playButton.addEventListener('click', togglePlay);
      E.prevButton.addEventListener('click', playPrevious);
      E.nextButton.addEventListener('click', playNext);

      // Full player controls
      E.fullPlayButton.addEventListener('click', togglePlay);
      E.fullPrevButton.addEventListener('click', playPrevious);
      E.fullNextButton.addEventListener('click', playNext);

      // Volume control
      E.volumeSlider.addEventListener("input", handleVolumeChange);
      E.volumeButton.addEventListener("click", toggleMute);

      // Player expand/minimize
      E.expandButton.addEventListener("click", () => {
        E.fullPlayer.classList.add("active");
      });

      E.minimizeButton.addEventListener("click", () => {
        E.fullPlayer.classList.remove("active");
      });

      // Define the debounced loadMore function
      const loadMoreDebounced = debounce(() => {
        if (!state.loadingMore && state.searchHasMore) {
          loadSearchResults(false);
        }
      }, 200);

      // Update scroll event listener
      window.addEventListener('scroll', () => {
        const { scrollTop, scrollHeight, clientHeight } = document.documentElement;
        if (scrollTop + clientHeight >= scrollHeight - 100) {
          loadMoreDebounced();
        }
      });

      // Window focus handling
      window.addEventListener('focus', () => {
        // Resume progress tracking if playing
        if (state.isPlaying) {
          requestAnimationFrame(syncProgress);
        }
      });
    }

    /**
     * Setup random song or handle shared link
     */
    async function setupInitialSong() {
      const urlParams = new URLSearchParams(window.location.search);
      const sharedSongId = urlParams.get('song');

      try {
        let songToPreload = null;

        if (sharedSongId) {
          const response = await fetch(`/api/song-info/${sharedSongId}`);
          songToPreload = await response.json();
        } else {
          songToPreload = await getRandomSong();
        }

        if (songToPreload) {
          state.currentSongId = songToPreload.id;
          E.miniPlayer.classList.remove("hidden");
          updatePlayerInfo(songToPreload);

          // Preload audio
          const streamData = await fetch(`/api/stream/${songToPreload.id}`).then(r => r.json());
          if (!streamData.error) {
            E.audio.src = streamData.url;
            E.audio.load();
          }

          // Add to queue
          if (!state.queue.includes(songToPreload.id)) {
            state.queue.push(songToPreload.id);
            state.queueIndex = state.queue.length - 1;
          }

          // Show play hint
          showPlayHint();

          // Load additional content
          loadLyrics(songToPreload.id);
          loadArtistInfo(songToPreload.artist);

          // Update URL if shared song
          if (sharedSongId) {
            history.replaceState({}, '', window.location.pathname);
          }
        }
      } catch (error) {
        console.error("Error preloading song:", error);
        showToast("Failed to load initial song");
      }
    }

    /**
     * Initialize application settings
     */
    // Updated initializeSettings function with proper audio context handling
    // 1. Fix AudioContext initialization
    function initializeAudioContext() {
      let audioContext;

      // Create context only after user interaction
      document.addEventListener('click', function initContext() {
        if (!audioContext) {
          const AudioContext = window.AudioContext || window.webkitAudioContext;
          if (AudioContext) {
            audioContext = new AudioContext();
            // Remove listener after first click
            document.removeEventListener('click', initContext);
          }
        }
      }, { once: true });

      return audioContext;
    }

    // 2. Fix setupInsights with null checks
    function setupInsights() {
      const insightsButton = document.querySelector('.player-controls .control-button[title="View Insights"]');
      const insightsModal = document.getElementById('insightsModal');
      const closeInsights = document.getElementById('closeInsights');

      if (!insightsButton || !insightsModal || !closeInsights) {
        console.warn('Insights elements not found, skipping setup');
        return;
      }

      insightsButton.addEventListener('click', async () => {
        insightsModal.style.display = 'block';
        await loadInsights();
      });

      closeInsights.addEventListener('click', () => {
        insightsModal.style.display = 'none';
      });
    }



    // 4. Update initialization function
    async function init() {
      try {
        // Initialize base settings with delayed AudioContext
        initializeSettings();

        // Setup all event listeners
        setupEventListeners();
        setupAudioEventListeners();

        // Initialize components with error handling
        setupSpeechRecognition();
        initializePlayerControls();

        // Initialize charts first
        const chartsInitialized = await initializeCharts();

        // Only setup insights if charts initialized successfully
        if (chartsInitialized) {
          setupInsights();
        }

        // Setup progress bars
        setupProgressBar(E.progressContainer, E.progressHover);
        setupProgressBar(E.fullProgressContainer, E.fullProgressHover);

        // Load initial song
        await setupInitialSong();

        // Load initial search results
        state.searchQuery = "";
        await loadSearchResults(true);

      } catch (error) {
        console.error("Initialization error:", error);
        showToast("An error occurred during initialization");
      }
    }

    // 5. Update initializeSettings function
    function initializeSettings() {
      // Set initial volume
      const savedVolume = localStorage.getItem("player-volume");
      if (savedVolume) {
        state.volume = parseInt(savedVolume);
        E.volumeSlider.value = state.volume;
        E.audio.volume = state.volume / 100;
        updateVolumeIcon(state.volume);
      }

      // Setup audio quality with delayed initialization
      let audioContext;
      document.addEventListener('click', () => {
        if (!audioContext && (window.AudioContext || window.webkitAudioContext)) {
          try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            if (audioContext?.audioWorklet) {
              setupAudioWorklet(audioContext).catch(console.warn);
            }
          } catch (err) {
            console.warn('AudioContext initialization failed:', err);
          }
        }
      }, { once: true });

      // Setup player appearance from preferences
      const savedTheme = localStorage.getItem("player-theme");
      if (savedTheme) {
        document.documentElement.setAttribute('data-theme', savedTheme);
      }
    }

    /**
     * Main initialization function
     * Entry point for the application
     */
    async function init() {
      try {
        // Initialize base settings
        initializeSettings();

        // Setup all event listeners
        setupEventListeners();
        setupAudioEventListeners();

        // Initialize components
        setupSpeechRecognition();
        initializePlayerControls();
        showToast("Welcome To Sangeet Premium...")
        await initializeCharts();
        setupInsights(); // Move setupInsights here

        // Setup progress bars
        setupProgressBar(E.progressContainer, E.progressHover);
        setupProgressBar(E.fullProgressContainer, E.fullProgressHover);

        // Load initial song
        await setupInitialSong();

        // Load initial search results
        state.searchQuery = "";
        await loadSearchResults(true);

      } catch (error) {
        console.error("Initialization error:", error);
        showToast("An error occurred during initialization");
      }
    }
    // Initialize all charts for the insights view
    async function initializeCharts() {
      try {
        // Create container divs for charts if they don't exist
        const chartContainers = ['dailyPatternChart', 'hourlyPatternChart', 'completionChart'];

        chartContainers.forEach(containerId => {
          const container = document.getElementById(containerId);
          if (container) {
            // Clear existing content
            container.innerHTML = '';
            // Add canvas element
            const canvas = document.createElement('canvas');
            canvas.id = `${containerId}Canvas`;
            container.appendChild(canvas);
          }
        });

        // Initialize empty charts with default configurations
        const ctx = {
          daily: document.getElementById('dailyPatternChartCanvas')?.getContext('2d'),
          hourly: document.getElementById('hourlyPatternChartCanvas')?.getContext('2d'),
          completion: document.getElementById('completionChartCanvas')?.getContext('2d')
        };

        // Only proceed if Chart.js is loaded
        if (!window.Chart) {
          console.warn('Chart.js not loaded yet');
          return false;
        }

        // Set default chart options
        Chart.defaults.color = '#94a3b8';
        Chart.defaults.font.family = 'system-ui, sans-serif';
        Chart.defaults.plugins.legend.display = false;
        Chart.defaults.animation.duration = 2000;
        Chart.defaults.elements.line.tension = 0.4;

        // Initialize empty charts
        if (ctx.daily) {
          window.chartInstances = window.chartInstances || {};
          window.chartInstances.daily = new Chart(ctx.daily, {
            type: 'bar',
            data: {
              labels: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
              datasets: [{
                data: Array(7).fill(0),
                backgroundColor: 'rgba(79,70,229,0.2)',
                borderColor: 'rgba(79,70,229,0.8)',
                borderWidth: 2,
                borderRadius: 4
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                y: {
                  beginAtZero: true,
                  grid: {
                    color: 'rgba(148,163,184,0.1)'
                  }
                },
                x: {
                  grid: {
                    display: false
                  }
                }
              }
            }
          });
        }

        if (ctx.hourly) {
          window.chartInstances.hourly = new Chart(ctx.hourly, {
            type: 'line',
            data: {
              labels: Array.from({ length: 24 }, (_, i) => `${i}:00`),
              datasets: [{
                data: Array(24).fill(0),
                backgroundColor: 'rgba(129,140,248,0.2)',
                borderColor: 'rgba(129,140,248,0.8)',
                borderWidth: 2,
                fill: true
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                y: {
                  beginAtZero: true,
                  grid: {
                    color: 'rgba(148,163,184,0.1)'
                  }
                },
                x: {
                  grid: {
                    display: false
                  }
                }
              }
            }
          });
        }

        if (ctx.completion) {
          window.chartInstances.completion = new Chart(ctx.completion, {
            type: 'doughnut',
            data: {
              labels: ['Complete', 'Partial', 'Skipped'],
              datasets: [{
                data: [0, 0, 0],
                backgroundColor: [
                  'rgba(79,70,229,0.8)',
                  'rgba(129,140,248,0.8)',
                  'rgba(199,210,254,0.8)'
                ],
                borderWidth: 0
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              cutout: '70%',
              plugins: {
                legend: {
                  display: true,
                  position: 'bottom'
                }
              }
            }
          });
        }

        return true;

      } catch (error) {
        console.error('Error initializing charts:', error);
        return false;
      }
    }
    /**
     * Error handler for uncaught errors
     */
    window.onerror = function (msg, url, line, col, error) {
      console.error("Global error:", { msg, url, line, col, error });
      // showToast("An unexpected error occurred");
      return false;
    };

    /**
     * Handle unhandled promise rejections
     */
    window.onunhandledrejection = function (event) {
      console.error("Unhandled promise rejection:", event.reason);
      showToast("An unexpected error occurred");
    };

    // Start the application
    document.addEventListener("DOMContentLoaded", init);

    // Export functions for potential external use
    window.PlayerAPI = {
      togglePlay,
      playNext,
      playPrevious,
      updateVolume: handleVolumeChange,
      toggleMute,
      seekTo: (time) => {
        if (E.audio.duration) {
          E.audio.currentTime = time;
        }
      }
    };
    /**
     * Lyrics and Artist Info Functions
     * Handles loading and displaying song metadata
     */

    /**
     * Load and display lyrics for a song
     * @param {string} songId - ID of song to load lyrics for
     */
    async function loadLyrics(songId) {
      try {
        const response = await fetch(`/api/lyrics/${songId}`);
        const lines = await response.json();

        if (!Array.isArray(lines) || !lines.length) {
          E.lyricsContainer.innerHTML = `<div class="lyrics-line">No lyrics available</div>`;
          return;
        }

        // Add lyrics with staggered animation
        E.lyricsContainer.innerHTML = '';
        lines.forEach((line, index) => {
          const div = document.createElement('div');
          div.className = 'lyrics-line';
          div.textContent = line;
          div.style.opacity = '0';
          div.style.transform = 'translateY(10px)';
          E.lyricsContainer.appendChild(div);

          setTimeout(() => {
            div.style.transition = 'all 0.3s ease';
            div.style.opacity = '1';
            div.style.transform = 'translateY(0)';
          }, index * 100);
        });

      } catch (error) {
        console.error('Error loading lyrics:', error);
        E.lyricsContainer.innerHTML = `<div class="lyrics-line">Unable to load lyrics</div>`;
      }
    }

    /**
     * Load and display artist information
     * @param {string} artistName - Name of artist to load info for
     */
    async function loadArtistInfo(artistName) {
      try {
        const response = await fetch(`/api/artist-info/${encodeURIComponent(artistName)}`);
        const data = await response.json();

        if (data.error) {
          throw new Error(data.error);
        }

        E.artistImage.src = data.thumbnail || '';
        E.artistName.textContent = data.name || artistName;
        E.artistYear.textContent = `Active since: ${data.year || 'Unknown'}`;
        E.artistGenre.textContent = `Genre: ${data.genres?.join(', ') || 'Various'}`;

        // Animate the artist info update
        const elements = [E.artistImage, E.artistName, E.artistYear, E.artistGenre];
        elements.forEach(el => {
          el.style.opacity = '0';
          el.style.transform = 'translateY(10px)';
          requestAnimationFrame(() => {
            el.style.transition = 'all 0.3s ease';
            el.style.opacity = '1';
            el.style.transform = 'translateY(0)';
          });
        });

      } catch (error) {
        console.error('Error loading artist info:', error);
        // Show fallback info
        E.artistImage.src = '';
        E.artistName.textContent = artistName;
        E.artistYear.textContent = 'Year: -';
        E.artistGenre.textContent = 'Genre: -';
      }
    }

    /**
     * Get a random song from available songs
     * @returns {Promise<Object>} Random song object
     */
    async function getRandomSong() {
      try {
        const response = await fetch('/api/random-song');
        if (!response.ok) throw new Error('Failed to get random song');
        return await response.json();
      } catch (error) {
        console.error('Error getting random song:', error);
        showToast("Failed to load random song");
        return null;
      }
    }
  </script>
  <script>
    // Add integration button to full player controls
    const integrationButton = document.createElement('button');
    integrationButton.className = 'control-button';
    integrationButton.innerHTML = '<span class="material-icons">code</span>';
    integrationButton.title = 'Get embed code';
    document.querySelector('.full-player .player-controls').appendChild(integrationButton);

    // Integration state
    const integrationState = {
      size: 'normal',
      theme: 'default',
      serverDomain: window.location.origin
    };

    // Add container to full player
    document.getElementById('fullPlayer').insertAdjacentHTML('beforeend', document.getElementById('integrationContainer').outerHTML);

    // Integration handling
    function initializeIntegration() {
      const container = document.getElementById('integrationContainer');
      const closeBtn = document.getElementById('closeIntegration');
      const copyBtn = document.getElementById('copyCode');
      const sizeBtns = container.querySelectorAll('.size-btn');
      const themeBtns = container.querySelectorAll('.theme-btn');

      // Show integration panel
      integrationButton.addEventListener('click', () => {
        container.style.display = 'block';
        updatePreviewAndCode();
      });

      // Close panel
      closeBtn.addEventListener('click', () => {
        container.style.display = 'none';
      });

      // Size selection
      sizeBtns.forEach(btn => {
        btn.addEventListener('click', () => {
          sizeBtns.forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          integrationState.size = btn.dataset.size;
          updatePreviewAndCode();
        });
      });

      // Theme selection
      themeBtns.forEach(btn => {
        btn.addEventListener('click', () => {
          themeBtns.forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          integrationState.theme = btn.dataset.theme;
          updatePreviewAndCode();
        });
      });

      // Copy code
      copyBtn.addEventListener('click', async () => {
        const code = document.getElementById('embedCode').textContent;
        try {
          await navigator.clipboard.writeText(code);
          copyBtn.innerHTML = '<span class="material-icons">check</span>';
          setTimeout(() => {
            copyBtn.innerHTML = '<span class="material-icons">content_copy</span>';
          }, 2000);
        } catch (err) {
          console.error('Failed to copy:', err);
          showToast('Failed to copy code');
        }
      });
    }

    document.addEventListener('DOMContentLoaded', async () => {
      try {
        // Load Chart.js first
        await loadScript('https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js');

        // Then load the datalabels plugin
        await loadScript('https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0');

        // Now wait a moment to ensure proper initialization
        await new Promise(resolve => setTimeout(resolve, 100));

        if (window.Chart && window.ChartDataLabels) {
          // Register the plugin
          Chart.register(ChartDataLabels);

          // Set default Chart.js options
          Chart.defaults.font.family = 'sans-serif';
          Chart.defaults.color = '#94a3b8';
          Chart.defaults.elements.line.borderJoinStyle = 'round';
          Chart.defaults.elements.bar.borderRadius = 4;

          await initializeCharts();
          setupInsights();
        } else {
          console.error('Chart.js or ChartDataLabels not properly loaded');
        }
      } catch (err) {
        console.error('Error initializing charts:', err);
      }
    });


    // Handle window resizing
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        if (window.chartInstances) {
          Object.values(window.chartInstances).forEach(chart => {
            if (chart && typeof chart.resize === 'function') {
              chart.resize();
            }
          });
        }
      }, 250);
    });

    // Helper function to load scripts
    function loadScript(src) {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
      });
    }



    // Update preview and code
    async function updatePreviewAndCode() {
      if (!state.currentSongId) return;

      const dimensions = {
        small: { width: 320, height: 160 },
        normal: { width: 400, height: 200 },
        large: { width: 500, height: 240 }
      };

      const { width, height } = dimensions[integrationState.size];

      // Update preview iframe
      const previewFrame = document.getElementById('previewFrame');
      previewFrame.style.width = `${width}px`;
      previewFrame.style.height = `${height}px`;

      const embedUrl = `${integrationState.serverDomain}/embed/${state.currentSongId}?size=${integrationState.size}&theme=${integrationState.theme}`;
      previewFrame.src = embedUrl;

      // Generate embed code
      const embedCode = `<iframe
  src="${embedUrl}"
  width="${width}"
  height="${height}"
  frameborder="0"
  allowtransparency="true"
  allow="encrypted-media"
  loading="lazy">
</iframe>`;

      document.getElementById('embedCode').textContent = embedCode;
    }

    // Initialize integration features
    initializeIntegration();

    // Update preview when song changes
    const originalLoadAndPlay = window.loadAndPlay;
    window.loadAndPlay = async function (songId) {
      await originalLoadAndPlay(songId);
      if (document.getElementById('integrationContainer').style.display === 'block') {
        updatePreviewAndCode();
      }
    };
    async function loadArtistDetails(artistName) {
      try {
        const response = await fetch(`/api/artist-info/${encodeURIComponent(artistName)}`);
        const data = await response.json();

        if (!response.ok) {
          throw new Error(data.error || 'Failed to load artist details');
        }

        // Update description
        document.getElementById('artistDescription').textContent = data.description || 'No description available';

        // Update stats
        document.getElementById('artistSubscribers').textContent = data.stats?.subscribers || '-';
        document.getElementById('artistViews').textContent = data.stats?.views || '-';
        document.getElementById('artistMonthlyListeners').textContent = data.stats?.monthlyListeners || '-';

        // Update top songs
        const topSongsList = document.getElementById('topSongsList');
        topSongsList.innerHTML = '';

        if (data.topSongs && data.topSongs.length > 0) {
          data.topSongs.forEach((song, index) => {
            const songElement = `
          <div class="top-song-item" data-song-id="${song.videoId}">
            <div class="song-number">${index + 1}</div>
            <div class="song-info">
              <div class="song-title">${song.title}</div>
              <div class="song-plays">${song.plays} plays</div>
            </div>
          </div>
        `;
            topSongsList.insertAdjacentHTML('beforeend', songElement);
          });

          // Add click handlers for top songs
          topSongsList.querySelectorAll('.top-song-item').forEach(item => {
            item.addEventListener('click', () => {
              const songId = item.dataset.songId;
              if (songId) {
                loadAndPlay(songId);
              }
            });
          });
        }

        // Update links
        const linksContainer = document.getElementById('artistLinks');
        linksContainer.innerHTML = '';

        if (data.links?.youtube) {
          const youtubeLink = `
        <a href="${data.links.youtube}" target="_blank" rel="noopener noreferrer" class="artist-link">
          <span class="material-icons">play_circle</span>
          YouTube Music
        </a>
      `;
          linksContainer.insertAdjacentHTML('beforeend', youtubeLink);
        }

        if (data.links?.official) {
          const officialLink = `
        <a href="${data.links.official}" target="_blank" rel="noopener noreferrer" class="artist-link">
          <span class="material-icons">language</span>
          Official Website
        </a>
      `;
          linksContainer.insertAdjacentHTML('beforeend', officialLink);
        }

      } catch (error) {
        console.error('Error loading artist details:', error);
        document.getElementById('artistDescription').textContent = 'Failed to load artist details';
      }
    }

    // Update the existing loadArtistInfo function to also call our new function
    const originalLoadArtistInfo = window.loadArtistInfo;
    window.loadArtistInfo = async function (artistName) {
      await originalLoadArtistInfo(artistName);
      await loadArtistDetails(artistName);
    };
    window.onunhandledrejection = function (event) {
      if (event.reason.message.includes('AudioWorklet')) {
        console.warn('AudioWorklet error suppressed:');
        event.preventDefault();
      }
    };

  </script>
  <script>
    // Enhanced insights visualization with Chart.js

    // Utility for generating gradients
    function createGradient(ctx, colorStart, colorEnd) {
      const gradient = ctx.createLinearGradient(0, 0, 0, 300);
      gradient.addColorStop(0, colorStart);
      gradient.addColorStop(1, colorEnd);
      return gradient;
    }




    // Enhanced initialization with chart responsiveness
    document.addEventListener('DOMContentLoaded', () => {
      // Load Chart.js with animation plugin
      Promise.all([
        loadScript('https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js'),
        loadScript('https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0')
      ]).then(() => {
        // Register Chart.js plugins
        Chart.register(ChartDataLabels);

        // Set default Chart.js options for all charts
        Chart.defaults.font.family = 'sans-serif';
        Chart.defaults.color = '#94a3b8';
        Chart.defaults.elements.line.borderJoinStyle = 'round';
        Chart.defaults.elements.bar.borderRadius = 4;
      }).catch(err => {
        console.error('Error loading chart libraries:', err);
        // showToast('Failed to load visualization libraries');
      });
    });
    // Add insights button to controls
    const insightsButton = document.createElement('button');
    insightsButton.className = 'control-button';
    insightsButton.innerHTML = '<span class="material-icons">insights</span>';
    insightsButton.title = 'View Insights';
    document.querySelector('.player-controls').appendChild(insightsButton);

    // Insights modal handling
    const insightsModal = document.getElementById('insightsModal');
    const closeInsights = document.getElementById('closeInsights');

    insightsButton.addEventListener('click', () => {
      insightsModal.style.display = 'block';
      loadInsights();
    });

    closeInsights.addEventListener('click', () => {
      insightsModal.style.display = 'none';
    });
    // Format duration for insights
    function formatInsightDuration(seconds) {
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const days = Math.floor(hours / 24);

      if (days > 0) {
        return `${days}d ${hours % 24}h`;
      } else if (hours > 0) {
        return `${hours}h ${minutes}m`;
      }
      return `${minutes}m`;
    }

    // Helper function to update recent activity
    function updateRecentActivity(activities) {
      const recentActivityList = document.getElementById('recentActivityList');
      recentActivityList.innerHTML = activities.map((activity, index) => `
    <div class="activity-item fade-in" style="animation-delay: ${index * 0.05}s">
      <div class="activity-time">${formatRelativeTime(new Date(activity.started_at))}</div>
      <div class="activity-info">
        <div class="activity-title">${activity.title}</div>
        <div class="activity-artist">${activity.artist}</div>
      </div>
      <div class="activity-completion">
        <div class="completion-bar" style="width: ${activity.completion}%"></div>
      </div>
    </div>
  `).join('');
    }

    // Initialize global chart instances object
    window.chartInstances = {
      daily: null,
      hourly: null,
      completion: null
    };
    const TimeUtils = {
      /**
       * Format time with IST timezone
       * @param {Date|string} date - Date to format
       * @param {boolean} includeDate - Whether to include date in output
       * @returns {string} Formatted time string
       */
      formatTime(date, includeDate = false) {
        if (!date) return '->';

        try {
          const d = new Date(date);
          // Convert to IST
          const istTime = new Date(d.getTime() + (5.5 * 60 * 60 * 1000));

          const options = {
            hour: 'numeric',
            minute: 'numeric',
            hour12: true,
            timeZone: 'Asia/Kolkata'
          };

          if (includeDate) {
            options.day = 'numeric';
            options.month = 'short';
            options.year = 'numeric';
          }

          return istTime.toLocaleString('en-IN', options) + ' IST';
        } catch (e) {
          console.error('Time formatting error:', e);
          return '->';
        }
      },

      /**
       * Format relative time in IST
       * @param {Date|string} date - Date to format
       * @returns {string} Relative time string
       */
      formatRelativeTime(date) {
        if (!date) return 'Unknown time';

        try {
          const now = new Date();
          const then = new Date(date);

          // Convert both to IST
          const istNow = new Date(now.getTime() + (5.5 * 60 * 60 * 1000));
          const istThen = new Date(then.getTime() + (5.5 * 60 * 60 * 1000));

          const diff = istNow - istThen;
          const seconds = Math.floor(diff / 1000);

          if (seconds < 60) return 'just now';
          if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
          if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
          if (seconds < 604800) return `${Math.floor(seconds / 86400)}d ago`;

          return this.formatTime(date, true);
        } catch (e) {
          console.error('Relative time error:', e);
          return 'Unknown time';
        }
      },

      /**
       * Get current IST time
       * @returns {Date} Current time in IST
       */
      getCurrentIST() {
        const now = new Date();
        return new Date(now.getTime() + (5.5 * 60 * 60 * 1000));
      },

      /**
       * Convert UTC to IST
       * @param {Date|string} date - UTC date to convert
       * @returns {Date} IST date
       */
      utcToIST(date) {
        if (!date) return null;
        const d = new Date(date);
        return new Date(d.getTime() + (5.5 * 60 * 60 * 1000));
      }
    };

    // Modified createDailyChart function
    function createDailyChart(dailyData) {
      try {
        const canvas = document.getElementById('dailyPatternChartCanvas');
        if (!canvas) {
          console.error('Daily chart canvas not found');
          return;
        }

        const ctx = canvas.getContext('2d');
        if (!ctx) {
          console.error('Could not get daily chart context');
          return;
        }

        // Clean up existing chart
        if (window.chartInstances.daily) {
          window.chartInstances.daily.destroy();
        }

        const gradient = ctx.createLinearGradient(0, 0, 0, 300);
        gradient.addColorStop(0, 'rgba(79,70,229,0.4)');
        gradient.addColorStop(1, 'rgba(79,70,229,0.1)');

        const labels = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        const data = labels.map((_, i) => dailyData[i] || 0);

        window.chartInstances.daily = new Chart(ctx, {
          type: 'bar',
          data: {
            labels,
            datasets: [{
              data,
              backgroundColor: gradient,
              borderColor: 'rgba(79,70,229,0.8)',
              borderWidth: 2,
              borderRadius: 6,
              barThickness: 'flex',
              maxBarThickness: 25
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false },
              tooltip: {
                mode: 'index',
                intersect: false,
                callbacks: {
                  label: (context) => `${context.parsed.y} plays`
                },
                backgroundColor: 'rgba(15,23,42,0.9)',
                titleColor: '#f8fafc',
                bodyColor: '#94a3b8',
                borderColor: 'rgba(148,163,184,0.1)',
                borderWidth: 1,
                padding: 10,
                displayColors: false
              }
            },
            scales: {
              x: { grid: { display: false }, ticks: { color: '#94a3b8' } },
              y: {
                beginAtZero: true,
                grid: { color: 'rgba(148,163,184,0.1)', drawBorder: false },
                ticks: {
                  color: '#94a3b8',
                  callback: (value) => value % 1 === 0 ? value : ''
                }
              }
            }
          }
        });
      } catch (error) {
        console.error('Error creating daily chart:', error);
      }
    }

    // Modified createHourlyChart function
    function createHourlyChart(hourlyData) {
      try {
        const canvas = document.getElementById('hourlyPatternChartCanvas');
        if (!canvas) {
          console.error('Hourly chart canvas not found');
          return;
        }

        const ctx = canvas.getContext('2d');
        if (!ctx) {
          console.error('Could not get hourly chart context');
          return;
        }

        // Clean up existing chart
        if (window.chartInstances.hourly) {
          window.chartInstances.hourly.destroy();
        }

        const gradient = ctx.createLinearGradient(0, 0, 0, 300);
        gradient.addColorStop(0, 'rgba(129,140,248,0.4)');
        gradient.addColorStop(1, 'rgba(129,140,248,0.1)');

        const labels = Array.from({ length: 24 }, (_, i) =>
          `${i.toString().padStart(2, '0')}:00`);
        const data = labels.map((_, i) => hourlyData[i] || 0);

        window.chartInstances.hourly = new Chart(ctx, {
          type: 'line',
          data: {
            labels,
            datasets: [{
              data,
              backgroundColor: gradient,
              borderColor: 'rgba(129,140,248,0.8)',
              borderWidth: 2,
              tension: 0.4,
              fill: true
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false }
            },
            scales: {
              x: {
                grid: { display: false },
                ticks: {
                  color: '#94a3b8',
                  maxRotation: 45,
                  minRotation: 45,
                  callback: (_, index) => index % 3 === 0 ? labels[index] : ''
                }
              },
              y: {
                beginAtZero: true,
                grid: {
                  color: 'rgba(148,163,184,0.1)',
                  drawBorder: false
                }
              }
            }
          }
        });
      } catch (error) {
        console.error('Error creating hourly chart:', error);
      }
    }
    // Modified createPatternCharts function
    function createPatternCharts(patterns) {
      try {
        createDailyChart(patterns.daily);
        createHourlyChart(patterns.hourly);
      } catch (error) {
        console.error('Error creating pattern charts:', error);
      }
    }
    async function loadInsights() {
      try {
        const response = await fetch('/api/insights');
        const data = await response.json();

        // Helper function to safely update element text
        const setElementText = (id, value) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        };

        // Update basic stats
        setElementText('totalListeningTime', formatInsightDuration(data.overview.total_time));
        setElementText('totalSongs', data.overview.total_songs.toLocaleString());
        setElementText('uniqueArtists', data.overview.unique_artists.toLocaleString());
        setElementText('averageDaily', Math.round(data.overview.average_daily).toString());

        // Update top artists list
        const topArtistsList = document.getElementById('topArtistsList');
        if (topArtistsList && data.top_artists) {
          topArtistsList.innerHTML = data.top_artists.map((artist, index) => `
        <div class="artist-card fade-in" style="animation-delay: ${index * 0.1}s">
          <div class="artist-rank">#${index + 1}</div>
          <div class="artist-info">
            <div class="artist-name">${artist.name}</div>
            <div class="artist-stats">
              ${artist.plays.toLocaleString()} plays • ${formatInsightDuration(artist.time)}
            </div>
          </div>
        </div>
      `).join('');
        }

        // Initialize charts
        if (!window.Chart) {
          await loadScript('https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js');
        }

        // Create/update charts
        await initializeCharts();

        if (data.listening_patterns) {
          createPatternCharts(data.listening_patterns);
        }



        // Update recent activity
        if (data.recent_activity) {
          const recentActivityList = document.getElementById('recentActivityList');
          if (recentActivityList) {
            recentActivityList.innerHTML = data.recent_activity.map((activity, index) => `
          <div class="activity-item fade-in" style="animation-delay: ${index * 0.05}s">

            <div class="activity-info">
              <div class="activity-title">${activity.title}</div>
              <div class="activity-artist">${activity.artist}</div>
            </div>
            <div class="activity-completion">
              <div class="completion-bar" style="width: ${activity.completion}%"></div>
            </div>
          </div>
        `).join('');
          }
        }

        // Update completion rate
        if (data.completion_rates?.average_completion) {
          setElementText('averageCompletion', `${data.completion_rates.average_completion.toFixed(1)}%`);
        }

      } catch (error) {
        console.error('Error loading insights:', error);
        showToast('Failed to load insights');
      }
    }
    function updateInsightElements(data) {
      // Helper function to safely update element text
      const setElementText = (id, value) => {
        const element = document.getElementById(id);
        if (element) element.textContent = value;
      };

      // Helper for creating artist cards
      const createArtistCard = (artist, index) => `
    <div class="artist-card fade-in" style="animation-delay: ${index * 0.1}s">
      <div class="artist-rank">#${index + 1}</div>
      <div class="artist-info">
        <div class="artist-name">${artist.name}</div>
        <div class="artist-stats">
          ${artist.plays.toLocaleString()} plays • ${formatInsightDuration(artist.time)}
        </div>
      </div>
    </div>
  `;

      // Helper for creating activity items
      const createActivityItem = (activity, index) => `
    <div class="activity-item fade-in" style="animation-delay: ${index * 0.05}s">
      <div class="activity-time">${formatRelativeTime(new Date(activity.started_at))}</div>
      <div class="activity-info">
        <div class="activity-title">${activity.title}</div>
        <div class="activity-artist">${activity.artist}</div>
      </div>
      <div class="activity-completion">
        <div class="completion-bar" style="width: ${activity.completion}%"></div>
      </div>
    </div>
  `;

      // Update overview stats
      setElementText('totalListeningTime', formatInsightDuration(data.overview.total_time));
      setElementText('totalSongs', data.overview.total_songs.toLocaleString());
      setElementText('uniqueArtists', data.overview.unique_artists.toLocaleString());
      setElementText('averageDaily', Math.round(data.overview.average_daily).toString());

      // Update top artists
      const topArtistsList = document.getElementById('topArtistsList');
      if (topArtistsList && data.top_artists) {
        topArtistsList.innerHTML = data.top_artists.map(createArtistCard).join('');
      }

      // Update recent activity
      const recentActivityList = document.getElementById('recentActivityList');
      if (recentActivityList && data.recent_activity) {
        recentActivityList.innerHTML = data.recent_activity.map(createActivityItem).join('');
      }

      // Update completion rate
      if (data.completion_rates?.average_completion) {
        setElementText('averageCompletion', `${data.completion_rates.average_completion.toFixed(1)}%`);
      }
    }
    function createActivityItem(activity, index) {
      const activityDate = new Date(activity.started_at);
      const formattedTime = formatRelativeTime(activityDate);

      return `
    <div class="activity-item fade-in" style="animation-delay: ${index * 0.05}s">
      <div class="activity-time">${formattedTime}</div>
      <div class="activity-info">
        <div class="activity-title">${activity.title}</div>
        <div class="activity-artist">${activity.artist}</div>
      </div>
      <div class="activity-completion">
        <div class="completion-bar" style="width: ${activity.completion}%"></div>
      </div>
    </div>
  `;
    }

    let currentListenId = null;
    let currentSessionId = null;

    async function startListeningSession(songId, title, artist) {
      try {
        const response = await fetch('/api/listen/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ songId, title, artist })
        });
        const data = await response.json();
        currentListenId = data.listenId;
        currentSessionId = data.sessionId;
      } catch (error) {
        console.error('Failed to start listening session:', error);
      }
    }

    async function endListeningSession(duration, listenedDuration) {
      if (!currentListenId) return;

      try {
        await fetch('/api/listen/end', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            listenId: currentListenId,
            duration,
            listenedDuration
          })
        });
      } catch (error) {
        console.error('Failed to end listening session:', error);
      } finally {
        currentListenId = null;
      }
    }
  </script>
  <script>
    if ('mediaSession' in navigator) {
      navigator.mediaSession.metadata = new MediaMetadata({
        title: '',
        artist: '',
        artwork: []
      });

      navigator.mediaSession.setActionHandler('play', () => {
        togglePlay();
      });
      navigator.mediaSession.setActionHandler('pause', () => {
        togglePlay();
      });
      navigator.mediaSession.setActionHandler('previoustrack', () => {
        playPrevious();
      });
      navigator.mediaSession.setActionHandler('nexttrack', () => {
        playNext();
      });
    }
    // Add history button to controls
    const historyButton = document.createElement('button');
    historyButton.className = 'control-button';
    historyButton.innerHTML = '<span class="material-icons">history</span>';
    historyButton.title = 'View History';
    document.querySelector('.player-controls').appendChild(historyButton);

    const historyModal = document.getElementById('historyModal');
    const closeHistory = document.getElementById('closeHistory');
    const historyList = document.getElementById('historyList');

    historyButton.addEventListener('click', () => {
      historyModal.style.display = 'block';
      loadHistory();
    });

    closeHistory.addEventListener('click', () => {
      historyModal.style.display = 'none';
    });
    class ImageLoader {
      constructor() {
        this.cache = new Map();
        this.corsEnabled = new Set();  // Track which domains support CORS
      }

      async loadImage(url, retryWithNoCors = true) {
        if (this.cache.has(url)) {
          return this.cache.get(url);
        }

        // For YouTube thumbnails, modify URL to use img.youtube.com
        if (url.includes('i.ytimg.com')) {
          url = url.replace('i.ytimg.com', 'img.youtube.com');
        }

        try {
          const imgUrl = await this.loadWithFallback(url, retryWithNoCors);
          this.cache.set(url, imgUrl);
          return imgUrl;
        } catch (error) {
          console.warn(`Failed to load image: ${url}`, error);
          return '/static/images/default-cover.png';
        }
      }

      async loadWithFallback(url, retryWithNoCors) {
        // Try loading with proxy first for known non-CORS domains
        if (!this.corsEnabled.has(new URL(url).hostname)) {
          try {
            const proxyUrl = `/api/proxy/image?url=${encodeURIComponent(url)}`;
            const response = await fetch(proxyUrl);
            if (response.ok) {
              const blob = await response.blob();
              return URL.createObjectURL(blob);
            }
          } catch (error) {
            console.warn('Proxy fetch failed, trying direct:', error);
          }
        }

        // Try direct load with CORS
        try {
          const response = await fetch(url, { mode: 'cors' });
          if (response.ok) {
            this.corsEnabled.add(new URL(url).hostname);
            const blob = await response.blob();
            return URL.createObjectURL(blob);
          }
        } catch (error) {
          console.warn('CORS fetch failed:', error);
        }

        // Last resort: return original URL for <img> to handle
        if (retryWithNoCors) {
          return url;
        }

        throw new Error('All image loading attempts failed');
      }
    }

    // Create a single instance for use throughout the app
    const imageLoader = new ImageLoader();
    // Update the ImageCache class with better CORS handling
    class ImageCache {
      constructor() {
        this.cache = new Map();
        this.retryCount = new Map();
        this.maxRetries = 4;
        this.initLocalStorage();
      }

      async loadImage(url, fallbackUrl = '/static/images/default-cover.png') {
        try {
          // First try memory cache
          if (this.cache.has(url)) {
            return this.cache.get(url);
          }

          // Then check localStorage cache
          const cacheData = JSON.parse(localStorage.getItem('imageCacheData') || '{}');
          if (cacheData[url] && Date.now() - cacheData[url].timestamp < 24 * 60 * 60 * 1000) {
            return cacheData[url].dataUrl;
          }

          // Try loading with CORS mode first
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.src = url;

          const imageData = await new Promise((resolve, reject) => {
            img.onload = () => {
              const canvas = document.createElement('canvas');
              canvas.width = img.width;
              canvas.height = img.height;
              const ctx = canvas.getContext('2d');
              ctx.drawImage(img, 0, 0);
              resolve(canvas.toDataURL('image/jpeg'));
            };
            img.onerror = () => reject(new Error('Image load failed'));
          });

          // Cache the successful result
          this.cache.set(url, imageData);
          cacheData[url] = {
            dataUrl: imageData,
            timestamp: Date.now()
          };
          localStorage.setItem('imageCacheData', JSON.stringify(cacheData));

          return imageData;

        } catch (error) {
          // If first attempt fails, try without CORS
          try {
            const response = await fetch(url, {
              mode: 'no-cors',
              cache: 'force-cache'
            });
            return url; // Return original URL if no-cors succeeds
          } catch (e) {
            console.warn(`Image load error for ${url}:`, e);
            return fallbackUrl;
          }
        }
      }

      initLocalStorage() {
        if (!localStorage.getItem('imageCacheData')) {
          localStorage.setItem('imageCacheData', JSON.stringify({}));
        }
        this.clearOldCache();
      }

      clearOldCache() {
        const cacheData = JSON.parse(localStorage.getItem('imageCacheData') || '{}');
        const now = Date.now();
        const oneDay = 24 * 60 * 60 * 1000;

        Object.keys(cacheData).forEach(key => {
          if (now - cacheData[key].timestamp > oneDay) {
            delete cacheData[key];
          }
        });

        localStorage.setItem('imageCacheData', JSON.stringify(cacheData));
      }

      blobToDataUrl(blob) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        });
      }
    }
    let offset = 0;
    const limit = 5; // Load 5 items per scroll
    let isLoading = false;
    let observer = null; // Store observer to manage it properly

    async function loadHistory() {
      const historyList = document.getElementById('historyList');
      if (!historyList) return;

      // Clear any existing observer to prevent duplicate observers
      if (observer) {
        observer.disconnect();
      }

      // Reset offset and clear the list explicitly
      offset = 0;
      historyList.innerHTML = Array(5).fill(0).map(() => `
    <div class="history-item skeleton">
      <div class="history-thumbnail skeleton"></div>
      <div class="history-info skeleton"></div>
    </div>
  `).join('');

      await loadMoreHistory();

      // Set up event delegation (only once)
      if (!historyList.dataset.listenerAdded) {
        historyList.addEventListener('click', (event) => {
          const historyItem = event.target.closest('.history-item');
          if (historyItem) {
            const songId = historyItem.dataset.id;
            loadAndPlay(songId);
            document.getElementById('historyModal').style.display = 'none';
          }
        });
        historyList.dataset.listenerAdded = 'true';
      }

      // Set up infinite scrolling
      const sentinel = document.createElement('div');
      sentinel.id = 'sentinel';
      historyList.appendChild(sentinel);

      observer = new IntersectionObserver(
        (entries) => {
          if (entries[0].isIntersecting && !isLoading) {
            loadMoreHistory();
          }
        },
        { rootMargin: '100px' }
      );
      observer.observe(sentinel);
    }

    async function loadMoreHistory() {
      if (isLoading) return;
      isLoading = true;

      const historyList = document.getElementById('historyList');
      try {
        const response = await fetch(`/api/queue?limit=${limit}&offset=${offset}`);
        if (!response.ok) throw new Error('Failed to fetch history');
        const history = await response.json();

        if (history.length === 0) return; // No more items to load

        const fragment = document.createDocumentFragment();
        history.forEach((item) => {
          const playedTime = TimeUtils.formatTime(item.played_at, true);
          const div = document.createElement('div');
          div.className = 'history-item';
          div.dataset.id = item.id;
          div.innerHTML = `
        <img class="history-thumbnail"
             src="${item.thumbnail || '/path/to/default/thumbnail.jpg'}"
             alt="${item.title || 'Unknown Title'}"
             loading="lazy">
        <div class="history-info">
          <div class="history-title">${item.title || 'Unknown Title'}</div>
          <div class="history-artist">${item.artist || 'Unknown Artist'}</div>
          <div class="history-time">${playedTime}</div>
        </div>
        <div class="history-play">
          <span class="material-icons">play_arrow</span>
        </div>
      `;
          fragment.appendChild(div);
        });

        // Clear skeleton or previous content if it's the first load
        if (offset === 0) historyList.innerHTML = '';
        historyList.appendChild(fragment);
        offset += limit;
      } catch (error) {
        console.error('Error loading history:', error);
        if (offset === 0) {
          historyList.innerHTML = `
        <div class="history-error">
          <span class="material-icons">error_outline</span>
          <p>Failed to load history. Please try again later.</p>
        </div>
      `;
        }
      } finally {
        isLoading = false;
      }
    }

    // Call this when the history modal is opened
    document.getElementById('historyButton').addEventListener('click', () => {
      loadHistory();
    });



    const historyStyles = `
.history-error {
    text-align: center;
    padding: 2rem;
    color: var(--text-secondary);
}

.history-error .material-icons {
    font-size: 3rem;
    margin-bottom: 1rem;
    color: var(--error-color);
}

.history-item {
    display: flex;
    align-items: center;
    padding: 1rem;
    border-radius: 12px;
    margin-bottom: 1rem;
    background: var(--surface-color);
    transition: all 0.3s ease;
    cursor: pointer;
}

.history-item:hover {
    background: var(--card-color);
    transform: translateY(-2px);
}

.history-thumbnail {
    width: 60px;
    height: 60px;
    border-radius: 8px;
    margin-right: 1rem;
    object-fit: cover;
    background-color: var(--card-color);
}

.history-play {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: var(--accent-gradient);
    display: flex;
    align-items: center;
    justify-content: center;
    margin-left: 1rem;
    opacity: 0;
    transition: all 0.3s ease;
}

.history-time {
    color: var(--text-secondary);
    font-size: 0.8rem;
    margin-top: 0.25rem;
}
`;

    // Add styles to document
    const styleSheet = document.createElement('style');
    styleSheet.textContent = historyStyles;
    document.head.appendChild(styleSheet);
    // Update chart initialization

    // Update createPatternCharts function with better error handling
    function createPatternCharts(patterns) {
      if (!patterns) return;

      const dailyCanvas = document.getElementById('dailyPatternChartCanvas');
      const hourlyCanvas = document.getElementById('hourlyPatternChartCanvas');

      if (dailyCanvas && patterns.daily) {
        createDailyChart(patterns.daily);
      }
      if (hourlyCanvas && patterns.hourly) {
        createHourlyChart(patterns.hourly);
      }
    }
    function createActivityItem(activity, index) {
      const timestamp = TimeUtils.formatRelativeTime(activity.started_at);

      return `
    <div class="activity-item fade-in" style="animation-delay: ${index * 0.05}s">
      <div class="activity-time">${timestamp}</div>
      <div class="activity-info">
        <div class="activity-title">${activity.title}</div>
        <div class="activity-artist">${activity.artist}</div>
      </div>
      <div class="activity-completion">
        <div class="completion-bar" style="width: ${activity.completion}%"></div>
      </div>
    </div>
  `;
    }


    // Time formatting utilities
    const TimeFormatter = {
      /**
       * Format seconds to MM:SS or HH:MM:SS
       * @param {number} seconds - Time in seconds
       * @returns {string} Formatted time string
       */
      formatTime(seconds) {
        if (!seconds || isNaN(seconds)) {
          seconds = 0;
        }

        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const secs = Math.floor(seconds % 60);

        if (hours > 0) {
          return `${hours}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
        }
        return `${minutes}:${String(secs).padStart(2, '0')}`;
      },

      /**
       * Format time with IST timezone
       * @param {Date|string} date - Date to format
       * @param {boolean} includeDate - Whether to include date in output
       * @returns {string} Formatted time string
       */
      formatDateTime(date, includeDate = false) {
        if (!date) return '->';

        try {
          const d = new Date(date);
          // Convert to IST
          const istTime = new Date(d.getTime() + (5.5 * 60 * 60 * 1000));

          const options = {
            hour: 'numeric',
            minute: 'numeric',
            hour12: true,
            timeZone: 'Asia/Kolkata'
          };

          if (includeDate) {
            options.day = 'numeric';
            options.month = 'short';
            options.year = 'numeric';
          }

          return istTime.toLocaleString('en-IN', options);
        } catch (e) {
          console.error('Time formatting error:', e);
          return '->';
        }
      },

      /**
       * Format relative time in IST
       * @param {Date|string} date - Date to format
       * @returns {string} Relative time string
       */
      formatRelativeTime(date) {
        if (!date) return 'Unknown time';

        try {
          const now = new Date();
          const then = new Date(date);

          // Convert both to IST
          const istNow = new Date(now.getTime() + (5.5 * 60 * 60 * 1000));
          const istThen = new Date(then.getTime() + (5.5 * 60 * 60 * 1000));

          const diff = istNow - istThen;
          const seconds = Math.floor(diff / 1000);

          if (seconds < 60) return 'just now';
          if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
          if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
          if (seconds < 604800) return `${Math.floor(seconds / 86400)}d ago`;

          return this.formatDateTime(date, true);
        } catch (e) {
          console.error('Relative time error:', e);
          return 'Unknown time';
        }
      },

      /**
       * Format duration for insights
       * @param {number} seconds - Duration in seconds
       * @returns {string} Formatted duration string
       */
      formatDuration(seconds) {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const days = Math.floor(hours / 24);

        if (days > 0) {
          return `${days}d ${hours % 24}h`;
        } else if (hours > 0) {
          return `${hours}h ${minutes}m`;
        }
        return `${minutes}m`;
      }
    };

    // Make formatTime available globally
    window.formatTime = TimeFormatter.formatTime;
    window.formatDateTime = TimeFormatter.formatDateTime;
    window.formatRelativeTime = TimeFormatter.formatRelativeTime;
    window.formatDuration = TimeFormatter.formatDuration;
  </script>
  <script>
    // Add hover effect to music notes
    document.querySelectorAll('.music-note').forEach(note => {
      setInterval(() => {
        note.style.left = Math.random() * 80 + 10 + '%';
      }, 3000);
    });
  </script>
  <script>
    // Create a notification manager class
    class NotificationManager {
      constructor() {
        this.init();
      }

      init() {
        // Create container for notifications
        const container = document.createElement('div');
        container.className = 'notification-container';
        document.body.appendChild(container);

        // Add styles
        const styles = document.createElement('style');
        styles.textContent = `
      .notification-container {
        position: fixed;
        top: 20px;
        left: 20px;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        gap: 10px;
        max-width: 320px;
      }

      .notification {
        background: var(--surface-color);
        border-left: 4px solid;
        border-radius: 8px;
        padding: 16px;
        color: var(--text-primary);
        display: flex;
        align-items: flex-start;
        gap: 12px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        transform-origin: left;
        animation: slideIn 0.3s ease forwards;
        cursor: pointer;
        position: relative;
        overflow: hidden;
        transition: all 0.3s ease;
      }

      .notification.removing {
        animation: slideOut 0.3s ease forwards;
      }

      .notification:hover {
        transform: translateX(5px);
      }

      .notification-icon {
        font-size: 20px;
        flex-shrink: 0;
      }

      .notification-content {
        flex-grow: 1;
        padding-right: 20px;
      }

      .notification-title {
        font-weight: 600;
        margin-bottom: 4px;
      }

      .notification-message {
        font-size: 0.9rem;
        opacity: 0.9;
      }

      .notification-close {
        position: absolute;
        top: 8px;
        right: 8px;
        padding: 4px;
        border-radius: 50%;
        cursor: pointer;
        opacity: 0.6;
        transition: all 0.2s;
        background: none;
        border: none;
        color: inherit;
      }

      .notification-close:hover {
        opacity: 1;
        background: rgba(255,255,255,0.1);
      }

      .notification-progress {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 3px;
        background: rgba(255,255,255,0.1);
      }

      .notification-progress-bar {
        height: 100%;
        background: currentColor;
        transition: width linear;
      }

      /* Types */
      .notification.success {
        background: rgba(34,197,94,0.1);
        border-color: #22c55e;
        color: #22c55e;
      }

      .notification.error {
        background: rgba(239,68,68,0.1);
        border-color: #ef4444;
        color: #ef4444;
      }

      .notification.warning {
        background: rgba(234,179,8,0.1);
        border-color: #eab308;
        color: #eab308;
      }

      .notification.info {
        background: rgba(59,130,246,0.1);
        border-color: #3b82f6;
        color: #3b82f6;
      }

      @keyframes slideIn {
        from {
          transform: translateX(-100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      @keyframes slideOut {
        from {
          transform: translateX(0);
          opacity: 1;
        }
        to {
          transform: translateX(-100%);
          opacity: 0;
        }
      }
    `;
        document.head.appendChild(styles);
      }

      show({ title, message, type = 'info', duration = 5000 }) {
        const container = document.querySelector('.notification-container');
        const notification = document.createElement('div');

        // Set notification content
        notification.className = `notification ${type}`;
        notification.innerHTML = `
      <div class="notification-icon">
        <span class="material-icons">
          ${this.getIcon(type)}
        </span>
      </div>
      <div class="notification-content">
        <div class="notification-title">${title}</div>
        <div class="notification-message">${message}</div>
      </div>
      <button class="notification-close">
        <span class="material-icons">close</span>
      </button>
      <div class="notification-progress">
        <div class="notification-progress-bar"></div>
      </div>
    `;

        // Add to container
        container.appendChild(notification);

        // Setup progress bar
        const progressBar = notification.querySelector('.notification-progress-bar');
        progressBar.style.width = '100%';
        progressBar.style.transitionDuration = `${duration}ms`;

        // Start progress
        requestAnimationFrame(() => {
          progressBar.style.width = '0%';
        });

        // Setup close button
        const closeBtn = notification.querySelector('.notification-close');
        closeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          this.remove(notification);
        });

        // Setup swipe to dismiss
        let startX = 0;
        let currentX = 0;

        notification.addEventListener('touchstart', (e) => {
          startX = e.touches[0].clientX;
        });

        notification.addEventListener('touchmove', (e) => {
          currentX = e.touches[0].clientX;
          const diff = currentX - startX;
          if (diff < 0) {
            notification.style.transform = `translateX(${diff}px)`;
          }
        });

        notification.addEventListener('touchend', () => {
          const diff = currentX - startX;
          if (diff < -100) {
            this.remove(notification);
          } else {
            notification.style.transform = '';
          }
        });

        // Auto remove after duration
        if (duration) {
          setTimeout(() => {
            if (container.contains(notification)) {
              this.remove(notification);
            }
          }, duration);
        }
      }

      remove(notification) {
        notification.classList.add('removing');
        setTimeout(() => {
          notification.remove();
        }, 300);
      }

      getIcon(type) {
        switch (type) {
          case 'success': return 'check_circle';
          case 'error': return 'error';
          case 'warning': return 'warning';
          case 'info': return 'info';
          default: return 'info';
        }
      }
    }

    // Create global instance
    window.notifications = new NotificationManager();

    // Usage examples:
    function showNotification(type, title, message, duration = 5000) {
      window.notifications.show({
        type,
        title,
        message,
        duration
      });
    }
    //usage
    // Show different types of notifications
    // showNotification('success', 'Success!', 'Operation completed successfully');
    // showNotification('error', 'Error!', 'Something went wrong');
    // showNotification('warning', 'Warning', 'Please backup before proceeding');
    // showNotification('info', 'Info', 'New update available');

    // // With custom duration (in milliseconds)
    // showNotification('info', 'Quick Note', 'This will disappear in 2 seconds', 2000);
  </script>
  <script>
    // Add enhanced progress loading styles
    const progressLoadingStyles = document.createElement('style');
    progressLoadingStyles.textContent = `
  /* Progress Skeleton Loading Styles */
  .progress-skeleton {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(
      90deg,
      var(--surface-color) 25%,
      var(--card-color) 50%,
      var(--surface-color) 75%
    );
    background-size: 200% 100%;
    animation: shimmer 1.5s infinite;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
  }

  /* Progress Bar Loading State */
  .progress-bar.loading {
    height: 12px;
    opacity: 0.3;
    transition: all 0.3s ease;
  }

  /* Progress Bar Loading Animation */
  @keyframes shimmer {
    0% { background-position: -200% 0; }
    100% { background-position: 200% 0; }
  }

  /* Time Indicator Loading State */
  .time-indicator.loading {
    opacity: 0.5;
    animation: pulse 1.5s infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 0.5; }
    50% { opacity: 0.2; }
  }

  /* Mobile Specific Progress Bar Adjustments */
  @media (max-width: 768px) {
    .progress-bar.loading {
      height: 14px;
    }
  }
`;
    document.head.appendChild(progressLoadingStyles);

    // Enhanced progress loading management
    function enhanceProgressLoading() {
      const audio = E.audio;
      const miniProgress = E.progressBar;
      const fullProgress = E.fullProgressBar;
      const progressSkeleton = E.progressSkeleton;
      const timeIndicators = document.querySelectorAll('.time-indicator');
      const progressBars = document.querySelectorAll('.progress-bar');

      function showLoading() {
        progressSkeleton.style.opacity = "1";
        progressBars.forEach(bar => bar.classList.add('loading'));
        timeIndicators.forEach(indicator => indicator.classList.add('loading'));
      }

      function hideLoading() {
        progressSkeleton.style.opacity = "0";
        progressBars.forEach(bar => bar.classList.remove('loading'));
        timeIndicators.forEach(indicator => indicator.classList.remove('loading'));
      }

      // Show loading on audio events
      audio.addEventListener('loadstart', showLoading);
      audio.addEventListener('waiting', showLoading);
      audio.addEventListener('seeking', showLoading);
      audio.addEventListener('stalled', showLoading);

      // Hide loading when ready
      audio.addEventListener('canplay', hideLoading);
      audio.addEventListener('playing', hideLoading);
      audio.addEventListener('seeked', hideLoading);

      // Handle errors
      audio.addEventListener('error', () => {
        hideLoading();
        showToast('error', 'Playback Error', 'Failed to load audio. Please try again.');
      });

      // Modify setupInitialSong to show loading state immediately
      const originalSetupInitialSong = window.setupInitialSong;
      window.setupInitialSong = async function () {
        showLoading(); // Show loading immediately
        try {
          await originalSetupInitialSong.apply(this, arguments);
        } catch (error) {
          console.error('Setup initial song error:', error);
          hideLoading();
        }
      };

      // Show loading state initially if not ready
      if (audio.readyState < 3) {
        showLoading();
      }
    }

    // Initialize the enhanced progress loading
    document.addEventListener('DOMContentLoaded', enhanceProgressLoading);
  </script>
  <script>
    //  async function setFavicons() {
    //       const response = await fetch('/data/download/icons/sangeet-home');
    //       const data = await response.json();
    //       const base64Data = data.base64;

    //       const sizes = [16, 32, 48, 64, 128, 256];
    //       sizes.forEach(size => {
    //           const link = document.createElement('link');
    //           link.rel = 'icon';
    //           link.type = 'image/png';
    //           link.sizes = `${size}x${size}`;
    //           link.href = `data:image/png;base64,${base64Data}`;
    //           document.head.appendChild(link);
    //       });
    //   }

    //   // Call the function to set favicons
    //   setFavicons();
    // async function setGifFavicon() {
    //       const response = await fetch('/data/download/icons/sangeet-home'); // Adjust the route as needed
    //       const data = await response.json();
    //       const base64Gif = data.base64;

    //       // Define common sizes for favicons
    //       const sizes = [16, 32, 48, 64, 128, 256];

    //       // Clear any existing favicons
    //       const existingFavicons = document.querySelectorAll('link[rel="icon"]');
    //       existingFavicons.forEach(favicon => favicon.remove());

    //       // Add new favicons for each size
    //       sizes.forEach(size => {
    //           const link = document.createElement('link');
    //           link.rel = 'icon';
    //           link.type = 'image/gif';
    //           link.sizes = `${size}x${size}`;
    //           link.href = `data:image/gif;base64,${base64Gif}`;
    //           document.head.appendChild(link);
    //       });
    //   }

    //   // Call the function to set the GIF favicon
    //   setGifFavicon();
  </script>
  <script>

    // Enhanced progress bar touch handling
    function setupProgressBar(container, progressHover, callback) {
      if (!container || !progressHover) return;

      let isDragging = false;
      let touchStartX = 0;
      let lastUpdateTime = 0;
      const updateThreshold = 50; // Minimum time between updates in ms

      // Touch start handler
      container.addEventListener("touchstart", (e) => {
        e.preventDefault();
        isDragging = true;
        touchStartX = e.touches[0].clientX;

        // Show visual feedback
        container.querySelector('.progress-bar').style.height =
          window.innerWidth <= 768 ? '14px' : '12px';
      });

      // Enhanced touch move handler with throttling
      container.addEventListener("touchmove", (e) => {
        if (!isDragging) return;

        const currentTime = Date.now();
        if (currentTime - lastUpdateTime < updateThreshold) return;

        const touch = e.touches[0];
        const rect = container.getBoundingClientRect();
        const percent = Math.max(0, Math.min(1, (touch.clientX - rect.left) / rect.width));

        progressHover.style.width = `${percent * 100}%`;

        if (E.audio.duration) {
          E.audio.currentTime = E.audio.duration * percent;
          lastUpdateTime = currentTime;
        }
      }, { passive: false });

      // Touch end handler
      container.addEventListener("touchend", (e) => {
        isDragging = false;
        container.querySelector('.progress-bar').style.height =
          window.innerWidth <= 768 ? '10px' : '8px';
      });

      // Mouse handling with enhanced sensitivity
      container.addEventListener("mousedown", (e) => {
        isDragging = true;
        const rect = container.getBoundingClientRect();
        const percent = (e.clientX - rect.left) / rect.width;

        if (E.audio.duration) {
          E.audio.currentTime = E.audio.duration * percent;
        }
      });

      container.addEventListener("mousemove", (e) => {
        const rect = container.getBoundingClientRect();
        const percent = ((e.clientX - rect.left) / rect.width) * 100;
        progressHover.style.width = `${percent}%`;

        if (isDragging && E.audio.duration) {
          E.audio.currentTime = E.audio.duration * (percent / 100);
        }
      });

      // Global mouse up handler
      document.addEventListener("mouseup", () => {
        isDragging = false;
      });

      // Prevent text selection while dragging
      container.addEventListener('selectstart', (e) => {
        if (isDragging) e.preventDefault();
      });
    }

    // Initialize enhanced progress bars
    document.addEventListener('DOMContentLoaded', () => {
      setupProgressBar(E.progressContainer, E.progressHover);
      setupProgressBar(E.fullProgressContainer, E.fullProgressHover);
    });
  </script>
  <script>
    /**
 * Session Management Enhancement
 */
    class SessionManager {
      constructor() {
        this.checkInterval = 10000; // Check every 10 seconds
        this.isCheckingSession = false;
        this.sessionInvalidated = false;
        this.initialize();
      }

      initialize() {
        // Start periodic checks
        this.startChecking();

        // Listen for visibility changes
        document.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'visible') {
            this.checkSessionStatus();
          }
        });

        // Check when user interacts after inactivity
        let lastActivity = Date.now();
        const activityEvents = ['mousedown', 'keydown', 'touchstart', 'click'];

        activityEvents.forEach(event => {
          document.addEventListener(event, () => {
            const now = Date.now();
            if (now - lastActivity > 30000) { // If inactive for 30s
              this.checkSessionStatus();
            }
            lastActivity = now;
          });
        });
      }

      async checkSessionStatus() {
        if (this.isCheckingSession || this.sessionInvalidated) return;

        this.isCheckingSession = true;

        try {
          const response = await fetch('/api/session-status');
          const data = await response.json();

          if (!response.ok || !data.valid) {
            this.sessionInvalidated = true;
            this.showSessionPopup(data.reason);
          }
        } catch (error) {
          console.error('Session check error:', error);
        } finally {
          this.isCheckingSession = false;
        }
      }

      startChecking() {
        setInterval(() => this.checkSessionStatus(), this.checkInterval);
      }

      showSessionPopup(reason) {
        // Stop all audio playback
        if (window.E && window.E.audio) {
          window.E.audio.pause();
        }

        // Create popup elements
        const overlay = document.createElement('div');
        overlay.className = 'session-popup-overlay';

        const popup = document.createElement('div');
        popup.className = 'session-popup';

        let title, message;
        switch (reason) {
          case 'logged_out_elsewhere':
            title = 'Session Ended';
            message = 'Your account has been logged in from another device. For security reasons, this session has been closed.';
            break;
          case 'expired':
            title = 'Session Expired';
            message = 'Your session has expired. Please log in again to continue.';
            break;
          default:
            title = 'Connection Lost';
            message = 'Your session is no longer active. Please log in again to continue.';
        }

        popup.innerHTML = `
      <div class="session-popup-icon">
        <span class="material-icons">error_outline</span>
      </div>
      <div class="session-popup-title">${title}</div>
      <div class="session-popup-message">${message}</div>
      <button class="session-popup-button">Login Again</button>
    `;

        // Add to document
        document.body.appendChild(overlay);
        document.body.appendChild(popup);

        // Handle button click
        const button = popup.querySelector('button');
        button.addEventListener('click', () => {
          window.location.href = '/login';
        });
      }
    }

    // Initialize session manager
    document.addEventListener('DOMContentLoaded', () => {
      window.sessionManager = new SessionManager();
    });
    class FestiveBackgroundSystem {
      constructor() {
        this.particleInterval = null;
        this.fps = 60;
        this.styles = `
      .bg-animation-wrapper {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
        overflow: hidden;
        pointer-events: none;
      }

      .festive-background {
        position: absolute;
        inset: -50px;
        opacity: 0.3;
        background: linear-gradient(
          45deg,
          #ff9a9e,    /* Light pink */
          #fad0c4,    /* Peach */
          #a18cd1,    /* Light purple */
          #fbc2eb,    /* Pink */
          #ff5458,    /* Bright red */
          #ffc853,    /* Yellow */
          #70ff57,    /* Green */
          #45caff     /* Blue */
        );
        background-size: 800% 800%;
        animation:
          gradientFlow 30s ease infinite,
          colorPulse 15s ease-in-out infinite;
        filter: blur(100px);
      }

      .festive-background::after {
        content: '';
        position: absolute;
        inset: 0;
        background: radial-gradient(
          circle at center,
          transparent 0%,
          rgba(0, 0, 0, 0.2) 100%
        );
      }

      .festive-particle {
        position: fixed;
        pointer-events: none;
        width: 10px;
        height: 10px;
        background: white;
        border-radius: 50%;
        opacity: 0;
        z-index: -1;
        transform-origin: center;
        will-change: transform, opacity;
      }

      @keyframes gradientFlow {
        0% { background-position: 0% 0%; }
        25% { background-position: 100% 50%; }
        50% { background-position: 50% 100%; }
        75% { background-position: 0% 50%; }
        100% { background-position: 0% 0%; }
      }

      @keyframes colorPulse {
        0%, 100% { filter: blur(100px) hue-rotate(0deg); }
        25% { filter: blur(100px) hue-rotate(90deg); }
        50% { filter: blur(100px) hue-rotate(180deg); }
        75% { filter: blur(100px) hue-rotate(270deg); }
      }

      @keyframes particleFloat {
        0% {
          transform: translateY(0) rotate(0deg);
          opacity: 0;
        }
        20% { opacity: 0.8; }
        100% {
          transform: translateY(-100vh) rotate(360deg);
          opacity: 0;
        }
      }

      @media (prefers-reduced-motion: reduce) {
        .festive-background {
          animation: none;
          background-size: 100% 100%;
          background-position: center;
        }
        .festive-particle {
          display: none;
        }
      }
    `;

        this.colors = [
          '#FF5458', // Red (Gulal)
          '#FFC853', // Yellow (Turmeric)
          '#70FF57', // Green (Spring)
          '#45CAFF', // Blue (Sky)
          '#FF9A9E', // Pink
          '#FAD0C4', // Peach
          '#A18CD1', // Purple
          '#FBC2EB'  // Light pink
        ];

        this.init();
      }

      init() {
        this.injectStyles();
        this.createBackgroundElements();
        this.startParticleSystem();
        this.setupPerformanceMonitoring();
        this.handleVisibilityChange();
      }

      injectStyles() {
        const styleSheet = document.createElement('style');
        styleSheet.textContent = this.styles;
        document.head.appendChild(styleSheet);
      }

      createBackgroundElements() {
        const wrapper = document.createElement('div');
        wrapper.className = 'bg-animation-wrapper';

        const background = document.createElement('div');
        background.className = 'festive-background';

        wrapper.appendChild(background);
        document.body.appendChild(wrapper);
      }

      createParticle() {
        if (document.hidden) return;

        const particle = document.createElement('div');
        particle.className = 'festive-particle';

        // Random properties
        const size = Math.random() * 15 + 5;
        const left = Math.random() * 100;
        const duration = Math.random() * 2 + 2;
        const color = this.colors[Math.floor(Math.random() * this.colors.length)];

        particle.style.cssText = `
      left: ${left}vw;
      width: ${size}px;
      height: ${size}px;
      background: ${color};
      animation: particleFloat ${duration}s ease-in-out forwards;
      box-shadow: 0 0 ${size / 2}px rgba(255,255,255,0.5);
    `;

        document.body.appendChild(particle);

        // Clean up particle
        particle.addEventListener('animationend', () => {
          particle.remove();
        });
      }

      startParticleSystem() {
        const spawnParticles = () => {
          if (document.hidden) return;
          const count = this.fps > 30 ? 3 : 1;
          for (let i = 0; i < count; i++) {
            this.createParticle();
          }
        };

        this.particleInterval = setInterval(spawnParticles, 1000);
      }

      setupPerformanceMonitoring() {
        let frameCount = 0;
        let lastTime = performance.now();

        const checkPerformance = () => {
          frameCount++;
          const currentTime = performance.now();

          if (currentTime - lastTime >= 1000) {
            this.fps = frameCount;
            frameCount = 0;
            lastTime = currentTime;
          }

          requestAnimationFrame(checkPerformance);
        };

        requestAnimationFrame(checkPerformance);
      }

      handleVisibilityChange() {
        document.addEventListener('visibilitychange', () => {
          if (document.hidden) {
            clearInterval(this.particleInterval);
          } else {
            this.startParticleSystem();
          }
        });
      }
    }

    // Initialize the system when the DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
      window.festiveBackground = new FestiveBackgroundSystem();
    });
  </script>
  <script>
    // Enhanced smooth seeking with both slide and tap support
    function initializeSmoothSeek() {
      const progressContainer = document.querySelector('.progress-container');
      const progressBar = document.querySelector('.progress-bar');
      const progress = document.querySelector('.progress');

      if (!progressContainer || !progressBar || !progress) return;

      let isDragging = false;
      let startX = 0;
      let startProgress = 0;

      // Touch event handlers
      progressContainer.addEventListener('touchstart', (e) => {
        isDragging = true;
        startX = e.touches[0].clientX;
        startProgress = progress.style.width ? parseInt(progress.style.width) : 0;

        // Get immediate seek position on tap
        const rect = progressContainer.getBoundingClientRect();
        const percent = (e.touches[0].clientX - rect.left) / rect.width;
        if (E.audio.duration) {
          E.audio.currentTime = E.audio.duration * percent;
          syncProgress();
        }
      }, { passive: true });

      progressContainer.addEventListener('touchmove', (e) => {
        if (!isDragging) return;

        const rect = progressContainer.getBoundingClientRect();
        const percent = (e.touches[0].clientX - rect.left) / rect.width;
        const boundedPercent = Math.max(0, Math.min(1, percent));

        progress.style.width = `${boundedPercent * 100}%`;

        if (E.audio.duration) {
          E.audio.currentTime = E.audio.duration * boundedPercent;
          syncProgress();
        }
      }, { passive: true });

      progressContainer.addEventListener('touchend', () => {
        isDragging = false;
      });

      // Mouse event handlers
      progressContainer.addEventListener('mousedown', (e) => {
        isDragging = true;
        startX = e.clientX;
        startProgress = progress.style.width ? parseInt(progress.style.width) : 0;

        const rect = progressContainer.getBoundingClientRect();
        const percent = (e.clientX - rect.left) / rect.width;
        if (E.audio.duration) {
          E.audio.currentTime = E.audio.duration * percent;
          syncProgress();
        }
      });

      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;

        const rect = progressContainer.getBoundingClientRect();
        const percent = (e.clientX - rect.left) / rect.width;
        const boundedPercent = Math.max(0, Math.min(1, percent));

        progress.style.width = `${boundedPercent * 100}%`;

        if (E.audio.duration) {
          E.audio.currentTime = E.audio.duration * boundedPercent;
          syncProgress();
        }
      });

      document.addEventListener('mouseup', () => {
        isDragging = false;
      });
    }
    // Initialize
    document.addEventListener('DOMContentLoaded', initializeSmoothSeek);
  </script>
  <script>
    function formatTime(seconds) {
      if (!seconds || isNaN(seconds)) seconds = 0;
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const secs = Math.floor(seconds % 60);
      return hours > 0
        ? `${hours}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`
        : `${minutes}:${String(secs).padStart(2, '0')}`;
    }
  </script>
  <script>
    // Hamburger Menu HTML
    const hamburgerMenuHTML = `
<div class="hamburger-menu">
  <button class="hamburger-button">
    <span class="material-icons">menu</span>
  </button>
  <div class="menu-content">
    <div class="menu-header">
      <h3>Sangeet Premium</h3>
      <button class="close-menu" style="
        padding: 0;
        background-color: #ff5f57;
        border: none;
        border-radius: 50%;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 20px;
        height: 20px;
        position: relative;
        &:hover {
          background-color: #ff7369;
        }
        &:active {
          background-color: #e04942;
          transform: scale(0.95);
        }
      ">
        <div style="
          width: 6px;
          height: 6px;
          background-color: rgba(0, 0, 0, 0.4);
          border-radius: 50%;
          transition: all 0.2s ease;
          position: absolute;
          &:hover {
            width: 8px;
            height: 2px;
            border-radius: 1px;
          }
        "></div>
      </button>
    </div>
    <div class="menu-items">
      <button class="menu-item" data-action="history">
        <span class="material-icons">history</span>
        <span>History</span>
      </button>
      <button class="menu-item" data-action="insights">
        <span class="material-icons">insights</span>
        <span>Insights</span>
      </button>
      <button class="menu-item" onclick="window.location.href='/logout'">
        <span class="material-icons">logout</span>
        <span>Logout</span>
      </button>
      <button class="menu-item" onclick="window.open('/get-extension', '_blank')">
        <span class="material-icons">get_app</span>
        <span>Get Extension</span>
      </button>
      <button class="menu-item" data-action="playlists">
        <span class="material-icons">playlist_play</span>
        <span>Playlists</span>
      </button>
      <a href="https://github.com/easy-ware/Sangeet-Premium" target="_blank" class="glass-button">
        <svg class="source-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/>
        </svg>
        <span class="button-text">Get Source</span>
        <div class="sparkle" style="top: 20%; left: 10%"></div>
        <div class="sparkle" style="top: 60%; left: 80%"></div>
        <div class="sparkle" style="top: 30%; left: 60%"></div>
      </a>

      <div style="
        position: relative;
        text-align: center;
        min-height: 200px;
        overflow: hidden;
        padding: 20px;
        background: linear-gradient(135deg, #1e1e2f, #2d2d44);
      ">
        <h1 style="
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
          color: white;
          background: linear-gradient(45deg, #ff3366, #ff6b6b);
          padding: 30px;
          border-radius: 15px;
          text-align: center;
          text-transform: uppercase;
          letter-spacing: 3px;
          text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
          box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
          position: relative;
          z-index: 1;
          transition: transform 0.3s ease;
        " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
          Sangeet Premium
          <span style="
            display: block;
            font-size: 16px;
            margin-top: 10px;
            font-weight: 300;
            text-transform: none;
            opacity: 0.9;
          ">Version v1.2.0</span>
        </h1>

        <!-- Animated Music Notes -->
        <div class="music-note" style="left: 10%; animation-delay: 0s;">♪</div>
        <div class="music-note" style="left: 20%; animation-delay: 0.5s;">♫</div>
        <div class="music-note" style="right: 15%; animation-delay: 1s;">♬</div>
        <div class="music-note" style="right: 25%; animation-delay: 1.5s;">♪</div>
      </div>
    </div>
  </div>
</div>
`;

    // Hamburger Menu CSS
    const hamburgerStyles = `
.hamburger-menu {
  position: fixed;
  top: 1rem;
  right: 1rem;
  z-index: 1000;
}

.hamburger-button {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: var(--accent-gradient);
  border: none;
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  box-shadow: 0 2px 10px rgba(0,0,0,0.2);
  transition: all 0.3s ease;
}

.hamburger-button:hover {
  transform: scale(1.1);
}

.menu-content {
  position: fixed;
  top: 0;
  right: -300px;
  width: 300px;
  height: 100vh;
  background: var(--surface-color);
  box-shadow: -5px 0 20px rgba(0,0,0,0.3);
  transition: right 0.3s ease;
  display: flex;
  flex-direction: column;
  overflow-y: scroll;
}

.menu-content::-webkit-scrollbar {
  width: 0;
}

.menu-content.active {
  right: 0;
}

.menu-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem;
  border-bottom: 1px solid rgba(255,255,255,0.1);
}

.menu-items {
  padding: 1rem;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.menu-item {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 1rem;
  border-radius: 12px;
  background: none;
  border: none;
  color: var(--text-primary);
  cursor: pointer;
  transition: all 0.3s ease;
  width: 100%;
  text-align: left;
}

.menu-item:hover {
  background: var(--card-color);
  transform: translateX(5px);
}

.menu-item .material-icons {
  color: var(--primary-light);
}

/* Skeleton Loading Styles */
.skeleton-loading {
  animation: skeletonPulse 1.5s infinite;
  background: linear-gradient(90deg, var(--surface-color) 25%, var(--card-color) 50%, var(--surface-color) 75%);
  background-size: 200% 100%;
  border-radius: 8px;
}

@keyframes skeletonPulse {
  0% { background-position: -200% 0; }
  100% { background-position: 200% 0; }
}

.history-item.skeleton {
  opacity: 0.7;
}

.history-thumbnail.skeleton {
  background: var(--card-color);
}

.history-info.skeleton::before {
  content: '';
  display: block;
  width: 70%;
  height: 20px;
  background: var(--card-color);
  margin-bottom: 8px;
  border-radius: 4px;
}
  .playlist-list {
  max-height: 400px;
  overflow-y: auto;
  margin-top: 1rem;
}

.playlist-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 1rem;
  background: var(--card-color);
  border-radius: 8px;
  margin-bottom: 0.5rem;
  cursor: pointer;
  transition: all 0.3s ease;
}

.playlist-item:hover {
  background: var(--surface-color);
  transform: translateY(-2px);
}

.playlist-item .playlist-info {
  flex-grow: 1;
}

.playlist-item .playlist-name {
  font-weight: 500;
  color: var(--text-primary);
}

.playlist-item .song-count {
  font-size: 0.9rem;
  color: var(--text-secondary);
}

.playlist-actions {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 1rem;
}

.playlist-controls {
  display: flex;
  gap: 0.5rem;
}

.control-btn {
  background: none;
  border: none;
  color: var(--primary-light);
  cursor: pointer;
  padding: 0.5rem;
}

.control-btn:hover {
  color: var(--accent-color);
}

.song-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.5rem 1rem;
  background: var(--surface-color);
  border-radius: 4px;
  margin-bottom: 0.3rem;
}

.song-item:hover {
  background: var(--card-color);
}

.song-item .play-btn {
  display: none;
}

.song-item:hover .play-btn {
  display: block;
}
`;



    // Function to Initialize Hamburger Menu
    function initHamburgerMenu() {
      // Insert HTML
      document.body.insertAdjacentHTML('beforeend', hamburgerMenuHTML);

      // Add Styles
      const style = document.createElement('style');
      style.textContent = hamburgerStyles;
      document.head.appendChild(style);

      // Select Elements
      const hamburgerButton = document.querySelector('.hamburger-button');
      const menuContent = document.querySelector('.menu-content');
      const closeMenu = document.querySelector('.close-menu');

      // Verify Elements Exist
      if (!hamburgerButton || !menuContent || !closeMenu) {
        console.error('Hamburger menu elements not found:', {
          hamburgerButton,
          menuContent,
          closeMenu,
        });
        return;
      }

      // Toggle Menu Function
      const toggleMenu = () => {
        menuContent.classList.toggle('active');
      };

      // Close Menu Function
      const closeMenuFunc = () => {
        menuContent.classList.remove('active');
      };

      // Event Listeners
      hamburgerButton.addEventListener('click', (e) => {
        e.stopPropagation();
        toggleMenu();
      });

      closeMenu.addEventListener('click', (e) => {
        e.stopPropagation();
        closeMenuFunc();
      });

      // Close on Outside Click
      document.addEventListener('click', (e) => {
        if (
          menuContent.classList.contains('active') &&
          !menuContent.contains(e.target) &&
          !hamburgerButton.contains(e.target)
        ) {
          closeMenuFunc();
        }
      });

      // Prevent Menu Close on Inside Click
      menuContent.addEventListener('click', (e) => {
        e.stopPropagation();
      });

      // Menu Item Actions
      document.querySelectorAll('.menu-item').forEach((item) => {
        item.addEventListener('click', () => {
          const action = item.dataset.action;
          closeMenuFunc();
          switch (action) {
            case 'history':
              document.getElementById('historyModal').style.display = 'block';
              loadHistory();
              break;
            case 'insights':
              document.getElementById('insightsModal').style.display = 'block';
              loadInsights();
              break;
            default:
              console.log(`Action ${action} not implemented`);
          }
        });
      });
    }

    // Ensure DOM is Loaded Before Initialization
    document.addEventListener('DOMContentLoaded', () => {
      initHamburgerMenu();
    });
  </script>
  <script>
   class PlaylistManager {
  constructor() {
    this.currentSongId = null;
    this.init();
  }

  init() {
    const addToPlaylistBtn = document.getElementById('addToPlaylistButton');
    addToPlaylistBtn.addEventListener('click', () => this.openPlaylistModal(true));

    const playlistModal = document.getElementById('playlistModal');
    const closePlaylist = document.getElementById('closePlaylist');
    const createPlaylistBtn = document.getElementById('createPlaylistBtn');

    closePlaylist.addEventListener('click', () => {
      playlistModal.style.display = 'none';
    });

    createPlaylistBtn.addEventListener('click', () => this.createNewPlaylist());

    document.querySelector('.menu-item[data-action="playlists"]').addEventListener('click', () => {
      this.openPlaylistModal(false);
    });

    document.addEventListener('songChange', (e) => {
      this.currentSongId = e.detail.songId;
    });
  }

  async openPlaylistModal(isAddMode) {
    const playlistModal = document.getElementById('playlistModal');
    const playlistList = document.getElementById('playlistList');
    const modalHeader = playlistModal.querySelector('.modal-header h2');
    playlistModal.style.display = 'block';
    playlistList.innerHTML = '<div class="skeleton-loading" style="height: 50px;"></div>';

    // Show the song title in add mode for confirmation
    if (isAddMode) {
      const songTitle = E.fullPlayerTitle.textContent || 'Current Song';
      modalHeader.textContent = `Add "${songTitle}" to Playlist`;
    } else {
      modalHeader.textContent = 'Playlists';
    }

    try {
      const response = await fetch('/api/playlists');
      const playlists = await response.json();
      // Filter unique playlists by ID to prevent duplicates
      const uniquePlaylists = Array.from(new Map(playlists.map(p => [p.id, p])).values());

      playlistList.innerHTML = '';
      uniquePlaylists.forEach(playlist => {
        const item = document.createElement('div');
        item.className = 'playlist-item';
        item.innerHTML = `
          <div class="playlist-info">
            <div class="playlist-name">${playlist.name}</div>
            <div class="song-count">${playlist.song_count} songs</div>
          </div>
          <div class="playlist-controls">
            ${isAddMode ?
              `<button class="control-btn add-to-playlist" data-playlist-id="${playlist.id}" title="Add to Playlist">
                <span class="material-icons">add</span>
              </button>` :
              `<button class="control-btn play-playlist" data-playlist-id="${playlist.id}" title="Play Playlist">
                <span class="material-icons">play_arrow</span>
              </button>
              <button class="control-btn shuffle-playlist" data-playlist-id="${playlist.id}" title="Shuffle Playlist">
                <span class="material-icons">shuffle</span>
              </button>
              <button class="control-btn share-playlist" data-playlist-id="${playlist.id}" title="Share Playlist">
                <span class="material-icons">share</span>
              </button>`}
          </div>
        `;
        playlistList.appendChild(item);

        if (isAddMode) {
          item.querySelector('.add-to-playlist').addEventListener('click', () =>
            this.addSongToPlaylist(playlist.id));
        } else {
          item.addEventListener('click', () => this.showPlaylistSongs(playlist.id, playlist.name));
          item.querySelector('.play-playlist').addEventListener('click', (e) => {
            e.stopPropagation();
            this.playPlaylist(playlist.id, false);
          });
          item.querySelector('.shuffle-playlist').addEventListener('click', (e) => {
            e.stopPropagation();
            this.playPlaylist(playlist.id, true);
          });
          item.querySelector('.share-playlist').addEventListener('click', (e) => {
            e.stopPropagation();
            this.sharePlaylist(playlist.id);
          });
        }
      });
    } catch (error) {
      console.error('Error loading playlists:', error);
      playlistList.innerHTML = '<p>Failed to load playlists.</p>';
    }
  }

  async createNewPlaylist() {
    const name = prompt('Enter playlist name:');
    if (!name) return;

    try {
      const response = await fetch('/api/playlists/create', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name })
      });
      if (response.ok) {
        this.openPlaylistModal(true);
        showToast('Playlist created successfully!', 'success');
      } else {
        throw new Error('Failed to create playlist');
      }
    } catch (error) {
      console.error('Error creating playlist:', error);
      showToast('Failed to create playlist', 'error');
    }
  }

  async addSongToPlaylist(playlistId) {
    if (!state.currentSongId) {
      showToast('No song selected', 'error');
      return;
    }
    try {
      // Fetch current songs in the playlist to check for duplicates
      const songsResponse = await fetch(`/api/playlists/${playlistId}/songs`);
      if (!songsResponse.ok) {
        throw new Error('Failed to fetch playlist songs');
      }
      const songs = await songsResponse.json();
      const songIds = songs.map(song => song.id);

      // Check if the song is already in the playlist
      if (songIds.includes(state.currentSongId)) {
        showToast('Song already in playlist', 'warning');
        return;
      }

      // Add the song if it's not a duplicate
      const addResponse = await fetch('/api/playlists/add_song', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ playlist_id: playlistId, song_id: state.currentSongId })
      });
      if (addResponse.ok) {
        showToast('Song added to playlist!', 'success');
        document.getElementById('playlistModal').style.display = 'none';
      } else {
        throw new Error('Failed to add song');
      }
    } catch (error) {
      console.error('Error adding song to playlist:', error);
      showToast('Failed to add song', 'error');
    }
  }

  async showPlaylistSongs(playlistId, playlistName) {
    const playlistList = document.getElementById('playlistList');
    playlistList.innerHTML = '';

    const header = document.createElement('div');
    header.className = 'pl-header';
    header.innerHTML = `
      <button class="pl-back-btn"><span class="material-icons">arrow_back</span></button>
      <h3>${playlistName}</h3>
    `;
    playlistList.appendChild(header);

    header.querySelector('.pl-back-btn').addEventListener('click', () => {
      this.openPlaylistModal(false);
    });

    const skeleton = document.createElement('div');
    skeleton.className = 'skeleton-loading';
    skeleton.style.height = '50px';
    playlistList.appendChild(skeleton);

    try {
      const response = await fetch(`/api/playlists/${playlistId}/songs`);
      const songs = await response.json();

      skeleton.remove();

      songs.forEach(song => {
        const songItem = document.createElement('div');
        songItem.className = 'pl-song-item';
        songItem.innerHTML = `
          <img src="${song.thumbnail || '/static/images/default-cover.png'}" alt="${song.title}" class="pl-song-thumb" loading="lazy">
          <div class="pl-song-info">
            <div class="pl-song-title">${song.title}</div>
            <div class="pl-song-artist">${song.artist}</div>
          </div>
          <button class="pl-control-btn pl-play-btn" data-song-id="${song.id}" title="Play Song">
            <span class="material-icons">play_arrow</span>
          </button>
        `;
        songItem.querySelector('.pl-play-btn').addEventListener('click', (e) => {
          e.stopPropagation();
          queueAndPlaySong(song.id);
        });
        playlistList.appendChild(songItem);
      });
    } catch (error) {
      console.error('Error loading playlist songs:', error);
      const errorMsg = document.createElement('p');
      errorMsg.textContent = 'Failed to load songs.';
      playlistList.appendChild(errorMsg);
    }
  }

  async playPlaylist(playlistId, shuffle) {
    try {
      const response = await fetch(`/api/playlists/${playlistId}/songs`);
      const songs = await response.json();
      if (!songs.length) {
        showToast('Playlist is empty', 'warning');
        return;
      }

      state.queue = songs.map(song => song.id);
      state.queueIndex = -1;
      if (shuffle) {
        state.queue = state.queue.sort(() => Math.random() - 0.5);
      }
      playNext();
    } catch (error) {
      console.error('Error playing playlist:', error);
      showToast('Failed to play playlist', 'error');
    }
  }

  async sharePlaylist(playlistId) {
    try {
      const response = await fetch(`/api/playlists/${playlistId}/share`, { method: 'POST' });
      const data = await response.json();
      const shareUrl = `${window.location.origin}/playlists/share/${data.share_id}`;

      if (navigator.share) {
        await navigator.share({
          title: 'Share Playlist',
          text: 'Check out my playlist!',
          url: shareUrl
        });
      } else {
        await navigator.clipboard.writeText(shareUrl);
        showToast('Playlist share link copied to clipboard!', 'success');
      }
    } catch (error) {
      console.error('Error sharing playlist:', error);
      showToast('Failed to share playlist', 'error');
    }
  }
}

// Initialize Playlist Manager
document.addEventListener('DOMContentLoaded', () => {
  new PlaylistManager();
});
  </script>
</body>

</html>