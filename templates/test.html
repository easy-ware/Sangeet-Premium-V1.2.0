<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Enhanced Music Player</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <link rel="icon" type="image/gif" href="/data/download/icons/sangeet-home" sizes="any">
  <link href="/design/index" rel="stylesheet">
  <style id="version-info">
    @keyframes float {
      0%, 100% { transform: translateY(0) rotate(0deg); }
      50% { transform: translateY(-20px) rotate(10deg); }
    }
    
    @keyframes twinkle {
      0%, 100% { opacity: 0; }
      50% { opacity: 1; }
    }
    
    .music-note {
      position: absolute;
      font-size: 24px;
      pointer-events: none;
      animation: float 3s infinite, twinkle 3s infinite;
    }
  </style>
  <style>
    .glass-button {
      position: relative;
      padding: 16px 32px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 12px;
      transition: all 0.3s ease;
      overflow: hidden;
      text-decoration: none; /* Added to remove underline from anchor */
    }

    .glass-button:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
    }

    .glass-button:active {
      transform: translateY(0px);
    }

    .button-text {
      color: #2a2a2a;
      font-family: system-ui, -apple-system, sans-serif;
      font-weight: 500;
      font-size: 18px;
      z-index: 1;
    }

    .source-icon {
      width: 24px;
      height: 24px;
      animation: bounce 2s infinite;
    }

    .sparkle {
      position: absolute;
      width: 4px;
      height: 4px;
      border-radius: 50%;
      background: #fff;
      animation: sparkle 1.5s infinite;
    }

    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-4px); }
    }

    @keyframes sparkle {
      0% { transform: scale(0) rotate(0deg); opacity: 0; }
      50% { transform: scale(1) rotate(180deg); opacity: 1; }
      100% { transform: scale(0) rotate(360deg); opacity: 0; }
    }

  </style>
</head>
<body>
  <div class="container">
    <!-- Enhanced Search Section -->
    <div class="search-container">
      <input
        type="text"
        class="search-input"
        id="searchInput"
        placeholder="Search for songs or tap mic to speak..."
      />
      <div class="search-icons">
        <span class="material-icons search-icon" id="micIcon">mic</span>
        <span class="material-icons search-icon broom-icon" id="broomIcon">cleaning_services</span>
      </div>
    </div>

    <!-- Insights Modal Section -->
    <div class="insights-modal" id="insightsModal">
      <div class="insights-content">
        <div class="insights-header">
          <h2>Listening Insights</h2>
          <button class="close-button" id="closeInsights">
            <span class="material-icons">close</span>
          </button>
        </div>

        <div class="insights-body">
          <!-- Overview Insight Section -->
          <section class="insight-section">
            <h3>Overview</h3>
            <div class="stats-grid">
              <div class="stat-card">
                <span class="material-icons">schedule</span>
                <div class="stat-value" id="totalListeningTime">0h</div>
                <div class="stat-label">Total Time</div>
              </div>
              <div class="stat-card">
                <span class="material-icons">music_note</span>
                <div class="stat-value" id="totalSongs">0</div>
                <div class="stat-label">Songs Played</div>
              </div>
              <div class="stat-card">
                <span class="material-icons">group</span>
                <div class="stat-value" id="uniqueArtists">0</div>
                <div class="stat-label">Artists</div>
              </div>
              <div class="stat-card">
                <span class="material-icons">trending_up</span>
                <div class="stat-value" id="averageDaily">0</div>
                <div class="stat-label">Daily Average</div>
              </div>
            </div>
          </section>

          <!-- Top Artists Insight Section -->
          <section class="insight-section">
            <h3>Top Artists</h3>
            <div class="top-artists-list" id="topArtistsList"></div>
          </section>

          <!-- Listening Patterns Insight Section -->
          <section class="insight-section">
            <h3>Listening Patterns</h3>
            <div class="patterns-container">
              <div class="pattern-chart">
                <h4>Daily Activity</h4>
                <div id="dailyPatternChart"></div>
              </div>
              <div class="pattern-chart">
                <h4>Hourly Activity</h4>
                <div id="hourlyPatternChart"></div>
              </div>
            </div>
          </section>

          <!-- Recent Activity Insight Section -->
          <section class="insight-section">
            <h3>Recent Activity</h3>
            <div class="recent-activity-list" id="recentActivityList"></div>
          </section>

          <!-- Completion Rates Insight Section -->
          <section class="insight-section">
            <h3>Listening Behavior</h3>
            <div class="completion-stats">
              <div class="completion-chart" id="completionChart"></div>
              <div class="completion-summary">
                <div class="completion-rate">
                  <span id="averageCompletion">0%</span>
                  <label>Average Completion</label>
                </div>
              </div>
            </div>
          </section>
        </div>
      </div>
    </div>

    <!-- Results Grid Section -->
    <div class="results-container" id="resultsContainer"></div>

    <!-- Infinite Loader Section -->
    <div id="infiniteLoader" style="text-align:center; color:var(--text-secondary); display:none;">
      Loading more...
    </div>
  </div>

  <!-- Mini Player Section -->
  <div class="mini-player hidden" id="miniPlayer">
    <div class="mini-player-info">
      <img src="" alt="Cover" class="mini-player-thumb" id="miniPlayerThumb"/>
      <div class="mini-player-text">
        <div class="mini-player-title" id="miniPlayerTitle">Title</div>
        <div class="mini-player-artist" id="miniPlayerArtist">Artist</div>
      </div>
    </div>

    <div class="player-controls">
      <button class="control-button" id="prevButton">
        <span class="material-icons">skip_previous</span>
      </button>
      <button class="control-button play-pause" id="playButton">
        <span class="material-icons">play_circle</span>
      </button>
      <button class="control-button" id="nextButton">
        <span class="material-icons">skip_next</span>
      </button>
    </div>

    <div class="progress-container" id="progressContainer">
      <div class="progress-bar">
        <div class="progress" id="progressBar"></div>
        <div class="progress-skeleton" id="progressSkeleton"></div>
        <div class="progress-hover" id="progressHover"></div>
      </div>
      <div class="time-indicator">
        <span id="currentTime">0:00</span>
        <span id="totalTime">0:00</span>
      </div>
    </div>

    <div class="volume-control">
      <button class="control-button" id="volumeButton">
        <span class="material-icons">volume_up</span>
      </button>
      <input
        type="range"
        class="volume-slider"
        min="0"
        max="100"
        value="100"
        id="volumeSlider"
      />
    </div>

    <button class="control-button expand" id="expandButton">
      <span class="material-icons">expand_less</span>
    </button>
  </div>

  <!-- Enhanced Full Player Section -->
  <div class="full-player" id="fullPlayer">
    <div class="full-player-header">
      <button class="control-button" id="minimizeButton">
        <span class="material-icons">expand_more</span>
      </button>
    </div>

    <div class="full-player-content">
      <div class="full-player-main">
        <div class="full-player-art">
          <img src="" alt="Cover" id="fullPlayerArt">
        </div>

        <div class="full-player-info">
          <div class="marquee">
            <div class="text" id="fullPlayerTitle">Choose a song to play</div>
          </div>
          <div class="full-player-artist" id="fullPlayerArtist">-</div>

          <div class="player-controls">
            <button class="control-button" id="fullPrevButton">
              <span class="material-icons">skip_previous</span>
            </button>
            <button class="control-button play-pause" id="fullPlayButton">
              <span class="material-icons">play_arrow</span>
            </button>
            <button class="control-button" id="fullNextButton">
              <span class="material-icons">skip_next</span>
            </button>
          </div>

          <div class="progress-container" id="fullProgressContainer">
            <div class="progress-bar">
              <div class="progress" id="fullProgressBar"></div>
              <div class="progress-hover" id="fullProgressHover"></div>
            </div>
            <div class="time-indicator">
              <span id="fullCurrentTime">0:00</span>
              <span id="fullTotalTime">0:00</span>
            </div>
          </div>
        </div>
      </div>

      <div class="lyrics-container" id="lyricsContainer">
        <div class="lyrics-line">Choose a song to see lyrics</div>
      </div>

      <div class="artist-info-container">
        <img src="" alt="Artist" class="artist-image" id="artistImage">
        <div class="artist-details">
          <div class="artist-name" id="artistName">Artist Name</div>
          <div class="artist-year" id="artistYear">Year: -</div>
          <div class="artist-genre" id="artistGenre">Genre: -</div>
        </div>
      </div>

      <div class="artist-overview-container">
        <div class="artist-overview-header">
          <h3>Artist Overview</h3>
        </div>

        <div class="artist-description">
          <h4>About</h4>
          <p id="artistDescription">Loading artist details...</p>
        </div>

        <div class="artist-stats">
          <div class="stat-card">
            <span class="material-icons">group</span>
            <div class="stat-value" id="artistSubscribers">-</div>
            <div class="stat-label">Subscribers</div>
          </div>
          <div class="stat-card">
            <span class="material-icons">visibility</span>
            <div class="stat-value" id="artistViews">-</div>
            <div class="stat-label">Total Views</div>
          </div>
          <div class="stat-card">
            <span class="material-icons">headphones</span>
            <div class="stat-value" id="artistMonthlyListeners">-</div>
            <div class="stat-label">Monthly Listeners</div>
          </div>
        </div>

        <div class="artist-top-songs">
          <h4>Popular Songs</h4>
          <div class="top-songs-list" id="topSongsList">
            <!-- Songs will be populated here -->
          </div>
        </div>

        <div class="artist-links" id="artistLinks">
          <!-- Links will be added here -->
        </div>
      </div>
    </div>

    <!-- Integration Container Section -->
    <div class="integration-container" id="integrationContainer" style="display: none;">
      <div class="integration-header">
        <h3 class="text-lg font-bold mb-4">Integrate this Song</h3>
        <button class="close-button" id="closeIntegration">
          <span class="material-icons">close</span>
        </button>
      </div>

      <div class="integration-options">
        <div class="integration-sizes">
          <label class="text-sm text-gray-300 mb-2">Choose Size:</label>
          <div class="size-buttons">
            <button class="size-btn active" data-size="small">Small</button>
            <button class="size-btn" data-size="normal">Normal</button>
            <button class="size-btn" data-size="large">Large</button>
          </div>
        </div>

        <div class="integration-themes">
          <label class="text-sm text-gray-300 mb-2">Choose Theme:</label>
          <div class="theme-buttons">
            <button class="theme-btn active" data-theme="default">
              <span class="theme-color default"></span>
              Default
            </button>
            <button class="theme-btn" data-theme="purple">
              <span class="theme-color purple"></span>
              Purple
            </button>
            <button class="theme-btn" data-theme="blue">
              <span class="theme-color blue"></span>
              Blue
            </button>
            <button class="theme-btn" data-theme="dark">
              <span class="theme-color dark"></span>
              Dark
            </button>
          </div>
        </div>

        <div class="integration-preview">
          <label class="text-sm text-gray-300 mb-2">Preview:</label>
          <div class="preview-container" id="previewContainer">
            <iframe id="previewFrame" frameborder="0" allowtransparency="true" allow="encrypted-media"></iframe>
          </div>
        </div>

        <div class="integration-code">
          <label class="text-sm text-gray-300 mb-2">Embed Code:</label>
          <div class="code-container">
            <pre id="embedCode" class="code-block"></pre>
            <button class="copy-btn" id="copyCode">
              <span class="material-icons">content_copy</span>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- History Modal Section -->
  <div id="historyModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Listening History</h2>
        <button class="close-button" id="closeHistory">
          <span class="material-icons">close</span>
        </button>
      </div>
      <div class="modal-body">
        <div id="historyList" class="history-list"></div>
      </div>
    </div>
  </div>

  <!-- Hidden Audio Element -->
  <audio id="audioElement" preload="auto"></audio>

  <!-- JavaScript and Script Files -->
  <script>
    // Javascript code from your provided code will be inserted here, as it is extensive and functional,
    // and directly inserting it here would make the HTML file very long and less readable for this response.
    // For the full Javascript code, please refer to the original provided code.
    // The javascript code includes all the functionalities for search, playback, UI updates, modals, insights, etc.
    // You can copy-paste the Javascript section from your original code here to complete the functionality.
  </script>
  <script>
    /**
     * Roadmap for the Music Player Code:

     * 1. Core Setup (JavaScript - top of script section):
     *    - State Management: `state` object holds all dynamic data like current song, queue, volume, search state.
     *    - DOM Element Caching: `E` object caches all frequently used HTML elements for efficient access.
     *    - Utility Functions: `debounce`, `showToast`, `formatTime` for general helpers.

     * 2. Speech Recognition (JavaScript):
     *    - `setupSpeechRecognition()`: Initializes and handles voice search using browser's SpeechRecognition API.
     *    - Starts/stops listening on mic icon click, updates search input with voice transcript.

     * 3. Player Controls (JavaScript):
     *    - `initializePlayerControls()`: Sets up event listeners for all player controls (play/pause, next, prev, volume, share, download).
     *    - `handleShare()`: Handles song sharing via Web Share API or clipboard copy.
     *    - `handleDownload()`: Initiates song download using an API endpoint.
     *    - `handleVolumeChange()`, `toggleMute()`, `updateVolumeIcon()`: Manages volume control and mute functionality.

     * 4. Media Playback & Progress Tracking (JavaScript):
     *    - `setupProgressBar()`: Initializes progress bar interaction for seeking.
     *    - `loadAndPlay()`: Loads song metadata and audio stream, starts playback.
     *    - `togglePlay()`, `playNext()`, `playPrevious()`: Controls playback state and queue navigation.
     *    - `updatePlayPauseUI()`, `syncProgress()`, `resetPlayerUI()`, `updatePlayerInfo()`, `showPlayHint()`: Functions for updating the UI based on player state.
     *    - `setupAudioEventListeners()`: Attaches event listeners to the `<audio>` element for playback events.

     * 5. Queue Management & Search Functionality (JavaScript):
     *    - `queueAndPlaySong()`, `addToQueue()`: Functions for managing the song queue.
     *    - `playNext()`, `playPrevious()`: Logic for playing next/previous songs in queue or fetching recommendations.
     *    - `loadSearchResults()`, `displayResults()`, `showSkeleton()`, `isItemDisplayed()`: Handles search requests, displays results, and manages loading states.
     *    - Debounced search input and clear search functionality.

     * 6. Initialization and Event Bindings (JavaScript):
     *    - `setupEventListeners()`: Binds all event listeners for keyboard shortcuts, player controls, scrolling, and window focus.
     *    - `setupInitialSong()`: Loads a random song or handles shared song links on initial load.
     *    - `initializeSettings()`: Sets initial volume and theme from local storage.
     *    - `init()`: Main initialization function that calls all setup functions.
     *    - `initializeCharts()`: Initializes chart.js charts for insights.

     * 7. Lyrics and Artist Info (JavaScript):
     *    - `loadLyrics()`: Fetches and displays song lyrics.
     *    - `loadArtistInfo()`: Fetches and displays artist information.
     *    - `getRandomSong()`: Fetches a random song from the API.

     * 8. Integration, Insights, History, and Notifications (JavaScript and HTML/CSS):
     *    - Integration panel for embedding the player.
     *    - Insights modal for listening statistics using Chart.js.
     *    - History modal to display listening history.
     *    - Notification system for user feedback and alerts.

     * 9. Session Management and Festive Background (JavaScript):
     *    - Session management to check for session invalidation and handle logout scenarios.
     *    - Festive background animation for visual enhancement.

     * 10. Smooth Seeking and Enhanced Progress Bar (JavaScript):
     *     - Smooth seeking implementation for better user experience when dragging or tapping the progress bar.
     *     - Enhanced progress bar loading state with skeleton animations.

     * 11. Hamburger Menu and Favicon (JavaScript, CSS, HTML):
     *     - Hamburger menu for navigation to history, insights, and logout.
     *     - Dynamic favicon setting (though commented out in the provided code).

     * 12. Time Formatting and Utility Functions (JavaScript):
     *     - `TimeFormatter` object to handle various time formatting needs.
     *     - Globalized `formatTime`, `formatDateTime`, `formatRelativeTime`, `formatDuration` functions.

     * 13. Error Handling and Performance Enhancements (JavaScript):
     *     - Global error handling for uncaught errors and promise rejections.
     *     - Performance monitoring for background animations and visibility change handling.
     *     - Image caching to improve thumbnail loading.

     * This roadmap provides a structured overview of the music player's functionality, broken down into logical components, making it easier to understand the codebase.
     */
  </script>
  <script>
    // Insert the Javascript code from the original provided code here to complete the functionality.
    // Due to the length of the JavaScript code, it is not included directly in this HTML for brevity in this response.
    // Please copy and paste the Javascript content from your original code into this section to make the player functional.
    /**
 * Enhanced Music Player - Complete JavaScript Implementation
 * =======================================================
 *
 * PART 1: Core Setup - State Management & DOM Elements
 */

/**
 * Global state management
 * Handles all dynamic data for the player including:
 * - Current playback state
 * - Queue management
 * - Search state
 * - Volume settings
 */
const state = {
  currentSongId: null,        // Currently playing/selected song ID
  recommendationsLoading: false, // Flag for recommendation loading state
  maxQueueSize: 50,          // Maximum songs in queue
  isPlaying: false,          // Current playback state
  queue: [],                 // Song queue array
  queueIndex: -1,            // Current position in queue
  volume: localStorage.getItem("player-volume") || 100, // Playback volume (0-100)
  searchQuery: "",           // Current search query
  searchPage: 0,             // Current page for infinite scroll
  searchLimit: 20,           // Items per page
  searchHasMore: true,       // Flag for more results available
  loadingMore: false,        // Flag for loading state
  displayedItems: new Set()  // Track displayed songs to prevent duplicates
};

/**
 * DOM Elements
 * Centralized access to all DOM elements used by the player
 * Grouped by functionality for better organization
 */
const E = {
  // Search Related Elements
  searchInput: document.getElementById("searchInput"),
  broomIcon: document.getElementById("broomIcon"),
  micIcon: document.getElementById("micIcon"),
  resultsContainer: document.getElementById("resultsContainer"),
  infiniteLoader: document.getElementById("infiniteLoader"),

  // Mini Player Elements
  miniPlayer: document.getElementById("miniPlayer"),
  miniPlayerThumb: document.getElementById("miniPlayerThumb"),
  miniPlayerTitle: document.getElementById("miniPlayerTitle"),
  miniPlayerArtist: document.getElementById("miniPlayerArtist"),
  playButton: document.getElementById("playButton"),
  prevButton: document.getElementById("prevButton"),
  nextButton: document.getElementById("nextButton"),

  // Progress Elements
  progressBar: document.getElementById("progressBar"),
  progressSkeleton: document.getElementById("progressSkeleton"),
  progressContainer: document.getElementById("progressContainer"),
  progressHover: document.getElementById("progressHover"),
  currentTime: document.getElementById("currentTime"),
  totalTime: document.getElementById("totalTime"),

  // Volume Elements
  volumeSlider: document.getElementById("volumeSlider"),
  volumeButton: document.getElementById("volumeButton"),

  // Full Player Elements
  expandButton: document.getElementById("expandButton"),
  minimizeButton: document.getElementById("minimizeButton"),
  fullPlayer: document.getElementById("fullPlayer"),
  fullPlayerArt: document.getElementById("fullPlayerArt"),
  fullPlayerTitle: document.getElementById("fullPlayerTitle"),
  fullPlayerArtist: document.getElementById("fullPlayerArtist"),

  // Content Elements
  lyricsContainer: document.getElementById("lyricsContainer"),
  artistImage: document.getElementById("artistImage"),
  artistName: document.getElementById("artistName"),
  artistYear: document.getElementById("artistYear"),
  artistGenre: document.getElementById("artistGenre"),

  // Full Player Controls
  fullPlayButton: document.getElementById("fullPlayButton"),
  fullPrevButton: document.getElementById("fullPrevButton"),
  fullNextButton: document.getElementById("fullNextButton"),
  fullProgressBar: document.getElementById("fullProgressBar"),
  fullProgressContainer: document.getElementById("fullProgressContainer"),
  fullProgressHover: document.getElementById("fullProgressHover"),
  fullCurrentTime: document.getElementById("fullCurrentTime"),
  fullTotalTime: document.getElementById("fullTotalTime"),

  // Audio Element
  audio: document.getElementById("audioElement")
};

/**
 * Core Utility Functions
 * Basic helper functions used throughout the application
 */

/**
 * Format time in seconds to MM:SS format
 * @param {number} sec - Time in seconds
 * @returns {string} Formatted time string
 */


/**
 * Debounce function for search input
 * @param {Function} fn - Function to debounce
 * @param {number} delay - Delay in milliseconds
 */
function debounce(fn, delay) {
  let t;
  return (...args) => {
    clearTimeout(t);
    t = setTimeout(() => fn(...args), delay);
  };
}

/**
 * Show toast notification
 * @param {string} message - Message to display
 */
function showToast(message , type = 'info') {
  // const toast = document.createElement('div');
  // toast.className = 'toast-notification';
  // toast.textContent = message;
  // document.body.appendChild(toast);
  // setTimeout(() => toast.remove(), 3000);
  showNotification(type, 'Sangeet Premium', message , 4000);
}

/**
 * Initial styles setup
 * Add required styles for toast notifications and controls
 */
const additionalStyles = document.createElement('style');
additionalStyles.textContent = `
  .toast-notification {
    position: fixed;
    bottom: 100px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 12px 24px;
    border-radius: 24px;
    font-size: 14px;
    z-index: 1000;
    animation: toastIn 0.3s ease, toastOut 0.3s ease 2.7s forwards;
  }

  @keyframes toastIn {
    from { opacity: 0; transform: translate(-50%, 20px); }
    to { opacity: 1; transform: translate(-50%, 0); }
  }

  @keyframes toastOut {
    from { opacity: 1; transform: translate(-50%, 0); }
    to { opacity: 0; transform: translate(-50%, 20px); }
  }

  .additional-controls {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    border-left: 1px solid rgba(255,255,255,0.1);
    padding-left: 1rem;
    margin-left: 0.5rem;
  }

  .full-player .additional-controls {
    border: none;
    padding-left: 0;
    margin-left: 1rem;
  }

  @media (max-width: 768px) {
    .additional-controls {
      border: none;
      padding-left: 0;
    }
  }
`;
document.head.appendChild(additionalStyles);
/**
 * Enhanced Music Player - Complete JavaScript Implementation
 * =======================================================
 *
 * PART 2: Speech Recognition & Player Controls
 */

/**
 * Speech Recognition Setup
 * Handles voice search functionality
 */
 const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
const recognition = SpeechRecognition ? new SpeechRecognition() : null;

function setupSpeechRecognition() {
  if (!recognition) {
    E.micIcon.style.display = 'none';
    return;
  }

  recognition.continuous = false;
  recognition.interimResults = false;
  recognition.lang = 'en-US';

  let isListening = false;

  function startListening() {
    try {
      isListening = true;
      E.micIcon.textContent = 'mic';
      E.micIcon.classList.add('listening');
      E.micIcon.style.color = 'var(--primary-light)';
      E.searchInput.placeholder = 'Listening...';
      recognition.start();
    } catch (err) {
      console.error('Speech recognition start error:', err);
      stopListening();
    }
  }

  function stopListening() {
    isListening = false;
    E.micIcon.classList.remove('listening');
    E.micIcon.style.color = '';
    E.micIcon.textContent = 'mic';
    E.searchInput.placeholder = 'Search for songs or tap mic to speak...';
    try {
      recognition.stop();
    } catch (err) {
      console.error('Speech recognition stop error:', err);
    }
  }

  // Speech Recognition Event Handlers
  recognition.onstart = () => {
    isListening = true;
    E.micIcon.textContent = 'mic';
    E.micIcon.classList.add('listening');
  };

  recognition.onend = () => {
    stopListening();
  };

  recognition.onresult = (event) => {
    const transcript = event.results[0][0].transcript;
    E.searchInput.value = transcript;
    E.searchInput.dispatchEvent(new Event('input'));

    E.micIcon.textContent = 'done';
    setTimeout(() => {
      E.micIcon.textContent = 'mic';
    }, 1000);
  };

  recognition.onerror = (event) => {
    console.error('Speech recognition error:', event.error);
    E.micIcon.textContent = 'mic_off';
    setTimeout(() => {
      stopListening();
    }, 1000);
  };

  // Mic Icon Event Listeners
  E.micIcon.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();
    isListening ? stopListening() : startListening();
  });

  E.micIcon.addEventListener('touchend', (e) => {
    e.preventDefault();
    e.stopPropagation();
    isListening ? stopListening() : startListening();
  });
}

/**
 * Player Controls Setup
 * Handles all player control buttons and functionality
 */

// Define control button templates
const additionalControls = `
<div class="additional-controls">
  <button class="control-button" id="downloadButton" title="Download song">
    <span class="material-icons">download</span>
  </button>
  <button class="control-button" id="shareButton" title="Share song">
    <span class="material-icons">share</span>
  </button>
</div>
`;

const fullPlayerControls = `
<div class="additional-controls">
  <button class="control-button" id="fullDownloadButton" title="Download song">
    <span class="material-icons">download</span>
  </button>
  <button class="control-button" id="fullShareButton" title="Share song">
    <span class="material-icons">share</span>
  </button>
</div>
`;

/**
 * Initialize Player Controls
 * Sets up all control buttons and their event handlers
 */
function initializePlayerControls() {
  // Add controls to players
  document.querySelector('.volume-control').insertAdjacentHTML('afterend', additionalControls);
  document.querySelector('.full-player .player-controls').insertAdjacentHTML('beforeend', fullPlayerControls);



  const controls = {
    share: {
      mini: document.getElementById('shareButton'),
      full: document.getElementById('fullShareButton')
    },
    download: {
      mini: document.getElementById('downloadButton'),
      full: document.getElementById('fullDownloadButton')
    }
  };

  /**
   * Handle song sharing
   * Provides native share or fallback to clipboard copy
   */
  async function handleShare() {
    if (!state.currentSongId) return;

    const shareUrl = `${window.location.origin}/share/open/${state.currentSongId}`;
    const songTitle = `${E.miniPlayerTitle.textContent} - ${E.miniPlayerArtist.textContent}`;

    try {
      if (navigator.share) {
        await navigator.share({
          title: songTitle,
          text: 'Check out this song!',
          url: shareUrl
        });
      } else {
        await navigator.clipboard.writeText(shareUrl);
        Object.values(controls.share).forEach(btn => {
          if (btn) {
            const icon = btn.querySelector('.material-icons');
            icon.textContent = 'check';
            setTimeout(() => icon.textContent = 'share', 2000);
          }
        });
        showToast('Share link copied to clipboard!');
      }
    } catch (err) {
      console.error('Share failed:', err);
    }
  }

  /**
   * Handle song download
   * Downloads current song and shows feedback
   */
  async function handleDownload() {
    if (!state.currentSongId) return;

    try {
      // Update button states
      Object.values(controls.download).forEach(btn => {
        if (btn) {
          const icon = btn.querySelector('.material-icons');
          icon.textContent = 'cloud_download';
        }
      });

      // Trigger download
      const link = document.createElement('a');
      link.href = `/api/download/${state.currentSongId}`;
      link.style.display = 'none';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);

      // Show success
      Object.values(controls.download).forEach(btn => {
        if (btn) {
          const icon = btn.querySelector('.material-icons');
          icon.textContent = 'cloud_done';
          setTimeout(() => icon.textContent = 'download', 2000);
        }
      });

    } catch (error) {
      console.error('Download error:', error);
      // Show error
      Object.values(controls.download).forEach(btn => {
        if (btn) {
          const icon = btn.querySelector('.material-icons');
          icon.textContent = 'cloud_off';
          setTimeout(() => icon.textContent = 'download', 2000);
        }
      });
      showToast('Download failed. Please try again.');
    }
  }

  // Attach event listeners to all controls
  Object.values(controls.share).forEach(btn => {
    btn?.addEventListener('click', handleShare);
  });

  Object.values(controls.download).forEach(btn => {
    btn?.addEventListener('click', handleDownload);
  });
}

/**
 * Volume Control Functions
 * Handles volume slider and mute functionality
 */
function handleVolumeChange(e) {
  state.volume = e.target.value;
  localStorage.setItem("player-volume", state.volume);
  E.audio.volume = state.volume / 100;
  updateVolumeIcon(state.volume);
}

function toggleMute() {
  if (E.audio.volume > 0) {
    E.volumeSlider.dataset.lastVol = state.volume;
    E.volumeSlider.value = 0;
    state.volume = 0;
  } else {
    const lastVol = E.volumeSlider.dataset.lastVol || 100;
    E.volumeSlider.value = lastVol;
    state.volume = lastVol;
  }
  E.volumeSlider.dispatchEvent(new Event("input"));
}

function updateVolumeIcon(volume) {
  const icon = E.volumeButton.querySelector(".material-icons");
  if (volume == 0) icon.textContent = "volume_off";
  else if (volume < 50) icon.textContent = "volume_down";
  else icon.textContent = "volume_up";
}
/**
 * Enhanced Music Player - Complete JavaScript Implementation
 * =======================================================
 *
 * PART 3: Media Playback & Progress Tracking
 */

/**
 * Progress Bar Setup
 * Handles progress bar interaction and display
 */
 function setupProgressBar(container, progressHover, callback) {
  if (!container || !progressHover) return;

  let isDragging = false;

  container.addEventListener("mousemove", (e) => {
    const rect = container.getBoundingClientRect();
    const percent = ((e.clientX - rect.left) / rect.width) * 100;
    progressHover.style.width = `${percent}%`;

    if (isDragging && E.audio.duration) {
      E.audio.currentTime = E.audio.duration * (percent / 100);
    }
  });

  container.addEventListener("mouseleave", () => {
    progressHover.style.width = "0%";
  });

  container.addEventListener("mousedown", () => {
    isDragging = true;
  });

  document.addEventListener("mouseup", () => {
    isDragging = false;
  });

  container.addEventListener("click", (e) => {
    const rect = container.getBoundingClientRect();
    const percent = (e.clientX - rect.left) / rect.width;
    if (E.audio.duration) {
      E.audio.currentTime = E.audio.duration * percent;
      if (callback) callback(percent);
    }
  });

  // Touch support
  container.addEventListener("touchstart", (e) => {
    e.preventDefault();
    isDragging = true;
  });

  container.addEventListener("touchmove", (e) => {
    if (!isDragging) return;
    const touch = e.touches[0];
    const rect = container.getBoundingClientRect();
    const percent = ((touch.clientX - rect.left) / rect.width) * 100;
    progressHover.style.width = `${percent}%`;

    if (E.audio.duration) {
      E.audio.currentTime = E.audio.duration * (percent / 100);
    }
  });

  container.addEventListener("touchend", () => {
    isDragging = false;
  });
}


/**
 * Toggle play/pause state
 */
// Add these functions to your JavaScript where you handle audio playback

// Track loading state
let isAudioLoading = false;
let playAfterLoad = false;

// Enhanced audio initialization
function initializeAudio() {
    const audioElement = document.getElementById('audioElement');

    // Loading states
    audioElement.addEventListener('loadstart', () => {
        isAudioLoading = true;
        console.log('Audio loading started');
    });

    audioElement.addEventListener('canplay', () => {
        isAudioLoading = false;
        console.log('Audio can play');
        if (playAfterLoad) {
            playAfterLoad = false;
            playAudioSafely();
        }
    });

    // Error handling
    audioElement.addEventListener('error', (e) => {
        isAudioLoading = false;
        playAfterLoad = false;
        console.error('Audio error:', e);
    });

    // Abort handling
    audioElement.addEventListener('abort', () => {
        isAudioLoading = false;
        playAfterLoad = false;
        console.log('Audio loading aborted');
    });
}


async function loadAndPlay(songId) {
    if (songId === state.currentSongId) {
        togglePlay();
        return;
    }

    state.currentSongId = songId;
    E.miniPlayer.classList.remove("hidden");

    // Reset UI placeholders
    resetPlayerUI();
    E.progressSkeleton.style.opacity = "1";

    try {
        // Reset states
        isAudioLoading = true;
        playAfterLoad = true;

        // Get song info and stream URL in parallel
        const [infoData, streamData] = await Promise.all([
            fetch(`/api/song-info/${songId}`).then(r => r.json()),
            fetch(`/api/stream/${songId}`).then(r => r.json())
        ]);

        if (infoData.error) throw new Error(infoData.error);
        if (streamData.error) throw new Error(streamData.error);

        // Start new listening session
        const sessionResponse = await fetch('/api/listen/start', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                songId: songId,
                title: infoData.title,
                artist: infoData.artist
            })
        });

        const sessionData = await sessionResponse.json();
        currentListenId = sessionData.listenId;

        // Update audio source
        E.audio.src = streamData.url;
        await E.audio.load();  // Ensure audio is loaded

        // Update both mini and full player info
        updatePlayerInfo(infoData);

        // Load additional content
        loadLyrics(songId);
        loadArtistInfo(infoData.artist);

        // Attempt to play safely
        await playAudioSafely();
        updatePlayPauseUI(true);
        syncProgress();

    } catch(e) {
        console.error("loadAndPlay error:", e);
        resetPlayerUI();
        showToast("Failed to load song. Please try again.");
    } finally {
        isAudioLoading = false;
    }
}

// Add this safe play function
async function playAudioSafely() {
    try {
        if (isAudioLoading) {
            playAfterLoad = true;
            return;
        }

        if (E.audio.readyState >= 2) { // HAVE_CURRENT_DATA or better
            await E.audio.play();
        } else {
            playAfterLoad = true;
            E.audio.addEventListener('canplay', () => {
                if (playAfterLoad) {
                    playAfterLoad = false;
                    E.audio.play().catch(console.error);
                }
            }, { once: true });
        }
    } catch (error) {
        console.error('Play error:', error);
        if (error.name === 'AbortError') {
            // Try again after a short delay
            setTimeout(playAudioSafely, 100);
        }
    }
}

// Update the togglePlay function to use safe play
function togglePlay() {
    if (!state.currentSongId) return;

    if (E.audio.paused) {
        playAudioSafely()
            .then(() => {
                updatePlayPauseUI(true);
            })
            .catch(err => {
                console.error("Play failed:", err);
                showToast("Playback failed. Please try again.");
            });
    } else {
        E.audio.pause();
        updatePlayPauseUI(false);
    }
}

// Add these event listeners to your audio element initialization
E.audio.addEventListener('loadstart', () => {
    isAudioLoading = true;
    E.progressSkeleton.style.opacity = "1";  // Keep original loading indicator
});

E.audio.addEventListener('canplay', () => {
    isAudioLoading = false;
    E.progressSkeleton.style.opacity = "0";  // Keep original loading indicator
    if (playAfterLoad) {
        playAfterLoad = false;
        playAudioSafely();
    }
});

E.audio.addEventListener('error', () => {
    isAudioLoading = false;
    playAfterLoad = false;
    E.progressSkeleton.style.opacity = "0";
});
// Initialize when page loads
document.addEventListener('DOMContentLoaded', initializeAudio);
/**
 * Update play/pause UI elements
 * @param {boolean} isPlaying - Current playing state
 */
function updatePlayPauseUI(isPlaying) {
  const miniIcon = E.playButton.querySelector(".material-icons");
  const fullIcon = E.fullPlayButton.querySelector(".material-icons");

  miniIcon.textContent = isPlaying ? "pause_circle" : "play_circle";
  fullIcon.textContent = isPlaying ? "pause" : "play_arrow";

  state.isPlaying = isPlaying;

  if (isPlaying) {
    requestAnimationFrame(syncProgress);
  }
}

/**
 * Sync progress between mini and full player
 */
function syncProgress() {
  if (E.audio.paused) return;

  const current = E.audio.currentTime;
  const duration = E.audio.duration;

  if (duration > 0) {
    const percent = (current / duration) * 100;
    E.progressBar.style.width = `${percent}%`;
    E.fullProgressBar.style.width = `${percent}%`;
  }

  E.currentTime.textContent = formatTime(current);
  E.fullCurrentTime.textContent = formatTime(current);
  E.totalTime.textContent = formatTime(duration);
  E.fullTotalTime.textContent = formatTime(duration);

  requestAnimationFrame(syncProgress);
}

/**
 * Reset player UI to loading state
 */
function resetPlayerUI() {
  E.fullPlayerTitle.innerHTML = "<span>Loading...</span>";
  E.fullPlayerArtist.textContent = "Buffering...";
  E.fullPlayerArt.src = "/static/images/loading.jpg";
  E.lyricsContainer.innerHTML = '<div class="lyrics-line">Loading lyrics...</div>';
  E.artistImage.src = "";
  E.artistName.textContent = "Loading...";
  E.artistYear.textContent = "Year: -";
  E.artistGenre.textContent = "Genre: -";
  E.progressSkeleton.style.opacity = "1";
}

/**
 * Update player info with song details
 * @param {Object} info - Song information
 */
function updatePlayerInfo(info) {
  // Update mini player
  E.miniPlayerThumb.src = info.thumbnail || '/static/images/default-cover.jpg';
  E.miniPlayerTitle.textContent = info.title || 'Unknown Title';
  E.miniPlayerArtist.textContent = info.artist || 'Unknown Artist';

  // Update full player
  E.fullPlayerArt.src = info.thumbnail || '/static/images/default-cover.jpg';
  E.fullPlayerTitle.innerHTML = `<span>${info.title || 'Unknown Title'}</span>`;
  E.fullPlayerArtist.textContent = info.artist || 'Unknown Artist';




  // Update document title
  document.title = `${info.title} - ${info.artist} | Music Player`;
  if ('mediaSession' in navigator) {
    navigator.mediaSession.metadata = new MediaMetadata({
      title: info.title || 'Unknown Title',
      artist: info.artist || 'Unknown Artist',
      artwork: [
        { src: info.thumbnail || '/static/images/default-cover.jpg', sizes: '512x512', type: 'image/jpg' }
      ]
    });
  }
}

/**
 * Show play hint for autoplay restriction
 */
function showPlayHint() {
  const hint = document.createElement('div');
  hint.style.cssText = `
    position: fixed;
    bottom: 120px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--accent-gradient);
    color: white;
    padding: 12px 24px;
    border-radius: 24px;
    font-size: 14px;
    z-index: 1000;
    animation: playHintPulse 2s infinite;
  `;
  hint.textContent = '👆 Click play to start listening';
  document.body.appendChild(hint);

  const removeHint = () => {
    hint.style.animation = 'toastOut 0.3s ease forwards';
    setTimeout(() => hint.remove(), 300);
  };

  document.addEventListener('click', removeHint, { once: true });
  setTimeout(removeHint, 5000);
}

/**
 * Audio Element Event Listeners
 */
 function setupAudioEventListeners() {
  E.audio.addEventListener("loadedmetadata", () => {
    E.totalTime.textContent = formatTime(E.audio.duration);
    E.fullTotalTime.textContent = formatTime(E.audio.duration);
    E.progressSkeleton.style.opacity = "0";
  });

  E.audio.addEventListener("playing", () => {
    state.isPlaying = true;
    updatePlayPauseUI(true);
  });

  E.audio.addEventListener("pause", () => {
    state.isPlaying = false;
    updatePlayPauseUI(false);
  });

  E.audio.addEventListener("ended", async () => {
    // End current listening session
    await endListeningSession(
      Math.round(E.audio.duration),
      Math.round(E.audio.currentTime)
    );

    state.isPlaying = false;
    updatePlayPauseUI(false);
    playNext();
  });

  // Add handler for when user stops/changes song
  E.audio.addEventListener("pause", async () => {
    if (currentListenId) {
      await endListeningSession(
        Math.round(E.audio.duration),
        Math.round(E.audio.currentTime)
      );
    }
  });

  E.audio.addEventListener("error", (e) => {
    console.error("Audio error:", e);
    showToast("Error playing audio. Please try again.");
  });
}

/**
 * Enhanced Music Player - Complete JavaScript Implementation
 * =======================================================
 *
 * PART 4: Queue Management & Search Functionality
 */

/**
 * Queue Management Functions
 * Handles song queue and playback sequence
 */

/**
 * Add song to queue and play
 * @param {string} songId - ID of song to queue and play
 */
 async function queueAndPlaySong(songId) {
  // Reset queue if it's too large
  if (state.queue.length > state.maxQueueSize) {
    state.queue = [];
    state.queueIndex = -1;
  }

  addToQueue(songId);
  state.queueIndex = state.queue.indexOf(songId);

  await loadAndPlay(songId);

  // Preload recommendations
  try {
    const response = await fetch(`/api/get-recommendations/${songId}`);
    const recommendations = await response.json();

    if (Array.isArray(recommendations)) {
      recommendations.forEach(song => {
        if (!state.queue.includes(song.id)) {
          state.queue.push(song.id);
        }
      });
    }
  } catch (error) {
    console.error("Error prefetching recommendations:", error);
  }
}

/**
 * Add song to queue
 * @param {string} songId - ID of song to add
 */
function addToQueue(songId) {
  if (!state.queue.includes(songId)) {
    state.queue.push(songId);
  }
}

/**
 * Play next song in queue
 */
async function playNext() {
  if (!state.currentSongId) return;

  // Try queue first
  if (state.queueIndex < state.queue.length - 1) {
    state.queueIndex++;
    await loadAndPlay(state.queue[state.queueIndex]);
    return;
  }

  try {
    const response = await fetch(`/api/play-sequence/${state.currentSongId}/next`);
    const data = await response.json();

    if (response.status === 404) {
      return; // No next song
    }

    if (data.error) {
      console.warn("Next song error:", data.error);
      return;
    }

    // Handle both single song and recommendations array
    const nextSongs = Array.isArray(data) ? data : [data];

    // Add new songs to queue
    nextSongs.forEach(song => {
      if (!state.queue.includes(song.id)) {
        state.queue.push(song.id);
      }
    });

    const nextSongId = nextSongs[0].id;
    state.queueIndex = state.queue.indexOf(nextSongId);
    await loadAndPlay(nextSongId);

  } catch (error) {
    console.error("Error playing next:", error);
    showToast("Failed to play next song");
  }
}

/**
 * Play previous song in queue
 */
async function playPrevious() {
  if (!state.currentSongId) return;

  // Try queue first
  if (state.queueIndex > 0) {
    state.queueIndex--;
    await loadAndPlay(state.queue[state.queueIndex]);
    return;
  }

  try {
    const response = await fetch(`/api/play-sequence/${state.currentSongId}/previous`);
    const data = await response.json();

    if (response.status === 404) {
      // If no previous song, restart current song if played for a while
      if (E.audio.currentTime > 3) {
        E.audio.currentTime = 0;
      }
      return;
    }

    if (data.error) {
      if (E.audio.currentTime > 3) {
        E.audio.currentTime = 0;
      }
      return;
    }

    // Add to queue if not exists
    if (!state.queue.includes(data.id)) {
      state.queue.splice(state.queueIndex, 0, data.id);
    }

    state.queueIndex = state.queue.indexOf(data.id);
    await loadAndPlay(data.id);

  } catch (error) {
    console.error("Error playing previous:", error);
    if (E.audio.currentTime > 3) {
      E.audio.currentTime = 0;
    }
  }
}

/**
 * Search Functionality
 * Handles search and results display
 */

/**
 * Load search results with deduplication
 * @param {boolean} reset - Whether to reset search state
 */
async function loadSearchResults(reset = false) {
  if (reset) {
    state.searchPage = 0;
    state.searchHasMore = true;
    E.resultsContainer.innerHTML = "";
    state.displayedItems.clear();
  }

  if (!state.searchHasMore) return;

  state.loadingMore = true;
  E.infiniteLoader.style.display = "block";

  if (state.searchPage === 0) {
    showSkeleton();
  }

  try {
    const q = encodeURIComponent(state.searchQuery);
    const page = state.searchPage;
    const limit = state.searchLimit;
    const res = await fetch(`/api/search?q=${q}&page=${page}&limit=${limit}`);
    const data = await res.json();

    if (state.searchPage === 0) {
      E.resultsContainer.innerHTML = "";
    }

    if (Array.isArray(data) && data.length > 0) {
      // Filter out duplicates
      const newItems = data.filter(item => !isItemDisplayed(item));

      if (newItems.length > 0) {
        displayResults(newItems);
        state.searchPage++;
      } else if (data.length === state.searchLimit) {
        // Try next page if all items were filtered
        state.searchPage++;
        await loadSearchResults(false);
      } else {
        state.searchHasMore = false;
      }
    } else {
      state.searchHasMore = false;
    }
  } catch(e) {
    console.error("Search error:", e);
    showToast("Search failed. Please try again.");
  }

  E.infiniteLoader.style.display = "none";
  state.loadingMore = false;
}

/**
 * Display search results
 * @param {Array} items - Array of song items to display
 */
function displayResults(items) {
  const uniqueItems = items.filter(song => {
    const key = `${song.id}-${song.title}-${song.artist}`.toLowerCase();
    if (state.displayedItems.has(song.id) || state.displayedItems.has(key)) {
      return false;
    }
    state.displayedItems.add(song.id);
    state.displayedItems.add(key);
    return true;
  });

  if (uniqueItems.length === 0) return;

  const html = uniqueItems.map(song => `
    <div class="song-card" data-id="${song.id}">
      <div class="song-thumbnail-container">
        <img class="song-thumbnail"
             loading="lazy"
             src="${song.thumbnail || "/static/images/default-cover.jpg"}"
             alt="${song.title}">
        <div class="song-duration">${formatTime(song.duration)}</div>
      </div>
      <div class="song-info">
        <div class="song-title">${song.title}</div>
        <div class="song-artist">${song.artist}</div>
      </div>
    </div>
  `).join("");

  E.resultsContainer.insertAdjacentHTML("beforeend", html);

  // Add click handlers
  document.querySelectorAll(".song-card").forEach(card => {
    if (!card.hasListener) {
      card.hasListener = true;
      card.addEventListener("click", () => {
        const sid = card.dataset.id;
        queueAndPlaySong(sid);
      });
    }
  });
}

/**
 * Show skeleton loading animation
 */
function showSkeleton() {
  E.resultsContainer.innerHTML = Array(6).fill("")
    .map(() => `<div class="song-card skeleton"></div>`)
    .join("");
}

/**
 * Check if item is already displayed
 * @param {Object} item - Song item to check
 * @returns {boolean} Whether item is already displayed
 */
// Enhanced isItemDisplayed function with better duplicate detection
function isItemDisplayed(item) {
  // Create a unique signature for the item that considers multiple factors
  const signatures = [
    // Basic ID check
    item.id,

    // Title + Artist normalized signature
    `${item.title}-${item.artist}`.toLowerCase().trim(),

    // Title-only normalized signature (for covers/remixes)
    item.title.toLowerCase().trim(),

    // Clean-text signature (removes special characters)
    `${item.title}-${item.artist}`
      .toLowerCase()
      .replace(/[^\w\s-]/g, '')
      .trim()
  ];

  // Check if any signature exists in our tracking set
  return signatures.some(sig => state.displayedItems.has(sig));
}

// Enhanced displayResults function with improved deduplication
function displayResults(items) {
  const uniqueItems = items.filter(song => {
    if (isItemDisplayed(song)) {
      return false;
    }

    // Add all signatures to tracking set
    const signatures = [
      song.id,
      `${song.title}-${song.artist}`.toLowerCase().trim(),
      song.title.toLowerCase().trim(),
      `${song.title}-${song.artist}`
        .toLowerCase()
        .replace(/[^\w\s-]/g, '')
        .trim()
    ];

    signatures.forEach(sig => state.displayedItems.add(sig));
    return true;
  });

  // Rest of the display logic...
  if (uniqueItems.length === 0) return;

  const html = uniqueItems.map(song => `
    <div class="song-card" data-id="${song.id}">
      <div class="song-thumbnail-container">
        <img class="song-thumbnail"
             loading="lazy"
             src="${song.thumbnail || "/static/images/default-cover.jpg"}"
             alt="${song.title}">
        <div class="song-duration">${formatTime(song.duration)}</div>
      </div>
      <div class="song-info">
        <div class="song-title">${song.title}</div>
        <div class="song-artist">${song.artist}</div>
      </div>
    </div>
  `).join("");

  E.resultsContainer.insertAdjacentHTML("beforeend", html);

  // Add click handlers
  document.querySelectorAll(".song-card").forEach(card => {
    if (!card.hasListener) {
      card.hasListener = true;
      card.addEventListener("click", () => {
        const sid = card.dataset.id;
        queueAndPlaySong(sid);
      });
    }
  });
}

// Reset function to clear tracking when starting new search
function resetSearchState() {
  state.searchPage = 0;
  state.searchHasMore = true;
  E.resultsContainer.innerHTML = "";
  state.displayedItems.clear();
}

// Debounced search function
const doSearch = debounce(() => {
  state.searchQuery = E.searchInput.value.trim();
  loadSearchResults(true);
}, 400);

// Search input handler
E.searchInput.addEventListener("input", () => {
  if (E.searchInput.value.trim()) {
    E.broomIcon.style.display = "block";
  } else {
    E.broomIcon.style.display = "none";
    state.displayedItems.clear();
  }
  doSearch();
});

// Clear search handler
E.broomIcon.addEventListener("click", () => {
  E.searchInput.value = "";
  E.broomIcon.style.display = "none";
  state.displayedItems.clear();
  doSearch();
});
/**
 * Enhanced Music Player - Complete JavaScript Implementation
 * =======================================================
 *
 * PART 5: Initialization and Event Bindings
 */

/**
 * Setup all event listeners
 * Initializes all event handlers for the application
 */
 function setupEventListeners() {
  // Keyboard shortcuts
  document.addEventListener("keydown", e => {
    // if (e.code === "Space" && e.target === document.body) {
    //   e.preventDefault();
    //   togglePlay();
    // }
    if (e.code === "Space" && e.target !== E.searchInput) {
      e.preventDefault();
      togglePlay();
    }
    if ((e.code === "ArrowLeft" || e.key === ",") && (e.ctrlKey || e.shiftKey)) {
      e.preventDefault();
      playPrevious();
    }
    if ((e.code === "ArrowRight" || e.key === ".") && (e.ctrlKey || e.shiftKey)) {
      e.preventDefault();
      playNext();
    }
    if (e.code === "Escape") {
      E.fullPlayer.classList.remove("active");
    }
  });

  // Mini player controls
  E.playButton.addEventListener('click', togglePlay);
  E.prevButton.addEventListener('click', playPrevious);
  E.nextButton.addEventListener('click', playNext);

  // Full player controls
  E.fullPlayButton.addEventListener('click', togglePlay);
  E.fullPrevButton.addEventListener('click', playPrevious);
  E.fullNextButton.addEventListener('click', playNext);

  // Volume control
  E.volumeSlider.addEventListener("input", handleVolumeChange);
  E.volumeButton.addEventListener("click", toggleMute);

  // Player expand/minimize
  E.expandButton.addEventListener("click", () => {
    E.fullPlayer.classList.add("active");
  });

  E.minimizeButton.addEventListener("click", () => {
    E.fullPlayer.classList.remove("active");
  });

  // Scroll handling for infinite load
  window.addEventListener("scroll", () => {
    if (state.loadingMore) return;
    const scrollPos = window.innerHeight + window.scrollY;
    const pageHeight = document.body.offsetHeight;
    if (scrollPos >= pageHeight - 300) {
      loadSearchResults(false);
    }
  });

  // Window focus handling
  window.addEventListener('focus', () => {
    // Resume progress tracking if playing
    if (state.isPlaying) {
      requestAnimationFrame(syncProgress);
    }
  });
}

/**
 * Setup random song or handle shared link
 */
async function setupInitialSong() {
  const urlParams = new URLSearchParams(window.location.search);
  const sharedSongId = urlParams.get('song');

  try {
    let songToPreload = null;

    if (sharedSongId) {
      const response = await fetch(`/api/song-info/${sharedSongId}`);
      songToPreload = await response.json();
    } else {
      songToPreload = await getRandomSong();
    }

    if (songToPreload) {
      state.currentSongId = songToPreload.id;
      E.miniPlayer.classList.remove("hidden");
      updatePlayerInfo(songToPreload);

      // Preload audio
      const streamData = await fetch(`/api/stream/${songToPreload.id}`).then(r => r.json());
      if (!streamData.error) {
        E.audio.src = streamData.url;
        E.audio.load();
      }

      // Add to queue
      if (!state.queue.includes(songToPreload.id)) {
        state.queue.push(songToPreload.id);
        state.queueIndex = state.queue.length - 1;
      }

      // Show play hint
      showPlayHint();

      // Load additional content
      loadLyrics(songToPreload.id);
      loadArtistInfo(songToPreload.artist);

      // Update URL if shared song
      if (sharedSongId) {
        history.replaceState({}, '', window.location.pathname);
      }
    }
  } catch (error) {
    console.error("Error preloading song:", error);
    showToast("Failed to load initial song");
  }
}

/**
 * Initialize application settings
 */
// Updated initializeSettings function with proper audio context handling
// 1. Fix AudioContext initialization
function initializeAudioContext() {
  let audioContext;

  // Create context only after user interaction
  document.addEventListener('click', function initContext() {
    if (!audioContext) {
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      if (AudioContext) {
        audioContext = new AudioContext();
        // Remove listener after first click
        document.removeEventListener('click', initContext);
      }
    }
  }, { once: true });

  return audioContext;
}

// 2. Fix setupInsights with null checks
function setupInsights() {
  const insightsButton = document.querySelector('.player-controls .control-button[title="View Insights"]');
  const insightsModal = document.getElementById('insightsModal');
  const closeInsights = document.getElementById('closeInsights');

  if (!insightsButton || !insightsModal || !closeInsights) {
    console.warn('Insights elements not found, skipping setup');
    return;
  }

  insightsButton.addEventListener('click', async () => {
    insightsModal.style.display = 'block';
    await loadInsights();
  });

  closeInsights.addEventListener('click', () => {
    insightsModal.style.display = 'none';
  });
}



// 4. Update initialization function
async function init() {
  try {
    // Initialize base settings with delayed AudioContext
    initializeSettings();

    // Setup all event listeners
    setupEventListeners();
    setupAudioEventListeners();

    // Initialize components with error handling
    setupSpeechRecognition();
    initializePlayerControls();

    // Initialize charts first
    const chartsInitialized = await initializeCharts();

    // Only setup insights if charts initialized successfully
    if (chartsInitialized) {
      setupInsights();
    }

    // Setup progress bars
    setupProgressBar(E.progressContainer, E.progressHover);
    setupProgressBar(E.fullProgressContainer, E.fullProgressHover);

    // Load initial song
    await setupInitialSong();

    // Load initial search results
    state.searchQuery = "";
    await loadSearchResults(true);

  } catch (error) {
    console.error("Initialization error:", error);
    showToast("An error occurred during initialization");
  }
}

// 5. Update initializeSettings function
function initializeSettings() {
  // Set initial volume
  const savedVolume = localStorage.getItem("player-volume");
  if (savedVolume) {
    state.volume = parseInt(savedVolume);
    E.volumeSlider.value = state.volume;
    E.audio.volume = state.volume / 100;
    updateVolumeIcon(state.volume);
  }

  // Setup audio quality with delayed initialization
  let audioContext;
  document.addEventListener('click', () => {
    if (!audioContext && (window.AudioContext || window.webkitAudioContext)) {
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        if (audioContext?.audioWorklet) {
          setupAudioWorklet(audioContext).catch(console.warn);
        }
      } catch (err) {
        console.warn('AudioContext initialization failed:', err);
      }
    }
  }, { once: true });

  // Setup player appearance from preferences
  const savedTheme = localStorage.getItem("player-theme");
  if (savedTheme) {
    document.documentElement.setAttribute('data-theme', savedTheme);
  }
}

/**
 * Main initialization function
 * Entry point for the application
 */
 async function init() {
  try {
    // Initialize base settings
    initializeSettings();

    // Setup all event listeners
    setupEventListeners();
    setupAudioEventListeners();

    // Initialize components
    setupSpeechRecognition();
    initializePlayerControls();
    showToast("Welcome To Sangeet Premium...")
    await initializeCharts();
    setupInsights(); // Move setupInsights here

    // Setup progress bars
    setupProgressBar(E.progressContainer, E.progressHover);
    setupProgressBar(E.fullProgressContainer, E.fullProgressHover);

    // Load initial song
    await setupInitialSong();

    // Load initial search results
    state.searchQuery = "";
    await loadSearchResults(true);

  } catch (error) {
    console.error("Initialization error:", error);
    showToast("An error occurred during initialization");
  }
}
// Initialize all charts for the insights view
async function initializeCharts() {
  try {
    // Create container divs for charts if they don't exist
    const chartContainers = ['dailyPatternChart', 'hourlyPatternChart', 'completionChart'];

    chartContainers.forEach(containerId => {
      const container = document.getElementById(containerId);
      if (container) {
        // Clear existing content
        container.innerHTML = '';
        // Add canvas element
        const canvas = document.createElement('canvas');
        canvas.id = `${containerId}Canvas`;
        container.appendChild(canvas);
      }
    });

    // Initialize empty charts with default configurations
    const ctx = {
      daily: document.getElementById('dailyPatternChartCanvas')?.getContext('2d'),
      hourly: document.getElementById('hourlyPatternChartCanvas')?.getContext('2d'),
      completion: document.getElementById('completionChartCanvas')?.getContext('2d')
    };

    // Only proceed if Chart.js is loaded
    if (!window.Chart) {
      console.warn('Chart.js not loaded yet');
      return false;
    }

    // Set default chart options
    Chart.defaults.color = '#94a3b8';
    Chart.defaults.font.family = 'system-ui, sans-serif';
    Chart.defaults.plugins.legend.display = false;
    Chart.defaults.animation.duration = 2000;
    Chart.defaults.elements.line.tension = 0.4;

    // Initialize empty charts
    if (ctx.daily) {
      window.chartInstances = window.chartInstances || {};
      window.chartInstances.daily = new Chart(ctx.daily, {
        type: 'bar',
        data: {
          labels: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
          datasets: [{
            data: Array(7).fill(0),
            backgroundColor: 'rgba(79,70,229,0.2)',
            borderColor: 'rgba(79,70,229,0.8)',
            borderWidth: 2,
            borderRadius: 4
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              grid: {
                color: 'rgba(148,163,184,0.1)'
              }
            },
            x: {
              grid: {
                display: false
              }
            }
          }
        }
      });
    }

    if (ctx.hourly) {
      window.chartInstances.hourly = new Chart(ctx.hourly, {
        type: 'line',
        data: {
          labels: Array.from({length: 24}, (_, i) => `${i}:00`),
          datasets: [{
            data: Array(24).fill(0),
            backgroundColor: 'rgba(129,140,248,0.2)',
            borderColor: 'rgba(129,140,248,0.8)',
            borderWidth: 2,
            fill: true
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              grid: {
                color: 'rgba(148,163,184,0.1)'
              }
            },
            x: {
              grid: {
                display: false
              }
            }
          }
        }
      });
    }

    if (ctx.completion) {
      window.chartInstances.completion = new Chart(ctx.completion, {
        type: 'doughnut',
        data: {
          labels: ['Complete', 'Partial', 'Skipped'],
          datasets: [{
            data: [0, 0, 0],
            backgroundColor: [
              'rgba(79,70,229,0.8)',
              'rgba(129,140,248,0.8)',
              'rgba(199,210,254,0.8)'
            ],
            borderWidth: 0
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          cutout: '70%',
          plugins: {
            legend: {
              display: true,
              position: 'bottom'
            }
          }
        }
      });
    }

    return true;

  } catch (error) {
    console.error('Error initializing charts:', error);
    return false;
  }
}
/**
 * Error handler for uncaught errors
 */
window.onerror = function(msg, url, line, col, error) {
  console.error("Global error:", { msg, url, line, col, error });
  // showToast("An unexpected error occurred");
  return false;
};

/**
 * Handle unhandled promise rejections
 */
window.onunhandledrejection = function(event) {
  console.error("Unhandled promise rejection:", event.reason);
  showToast("An unexpected error occurred");
};

// Start the application
document.addEventListener("DOMContentLoaded", init);

// Export functions for potential external use
window.PlayerAPI = {
  togglePlay,
  playNext,
  playPrevious,
  updateVolume: handleVolumeChange,
  toggleMute,
  seekTo: (time) => {
    if (E.audio.duration) {
      E.audio.currentTime = time;
    }
  }
};
/**
 * Lyrics and Artist Info Functions
 * Handles loading and displaying song metadata
 */

/**
 * Load and display lyrics for a song
 * @param {string} songId - ID of song to load lyrics for
 */
 async function loadLyrics(songId) {
  try {
    const response = await fetch(`/api/lyrics/${songId}`);
    const lines = await response.json();

    if (!Array.isArray(lines) || !lines.length) {
      E.lyricsContainer.innerHTML = `<div class="lyrics-line">No lyrics available</div>`;
      return;
    }

    // Add lyrics with staggered animation
    E.lyricsContainer.innerHTML = '';
    lines.forEach((line, index) => {
      const div = document.createElement('div');
      div.className = 'lyrics-line';
      div.textContent = line;
      div.style.opacity = '0';
      div.style.transform = 'translateY(10px)';
      E.lyricsContainer.appendChild(div);

      setTimeout(() => {
        div.style.transition = 'all 0.3s ease';
        div.style.opacity = '1';
        div.style.transform = 'translateY(0)';
      }, index * 100);
    });

  } catch (error) {
    console.error('Error loading lyrics:', error);
    E.lyricsContainer.innerHTML = `<div class="lyrics-line">Unable to load lyrics</div>`;
  }
}

/**
 * Load and display artist information
 * @param {string} artistName - Name of artist to load info for
 */
async function loadArtistInfo(artistName) {
  try {
    const response = await fetch(`/api/artist-info/${encodeURIComponent(artistName)}`);
    const data = await response.json();

    if (data.error) {
      throw new Error(data.error);
    }

    E.artistImage.src = data.thumbnail || '';
    E.artistName.textContent = data.name || artistName;
    E.artistYear.textContent = `Active since: ${data.year || 'Unknown'}`;
    E.artistGenre.textContent = `Genre: ${data.genres?.join(', ') || 'Various'}`;

    // Animate the artist info update
    const elements = [E.artistImage, E.artistName, E.artistYear, E.artistGenre];
    elements.forEach(el => {
      el.style.opacity = '0';
      el.style.transform = 'translateY(10px)';
      requestAnimationFrame(() => {
        el.style.transition = 'all 0.3s ease';
        el.style.opacity = '1';
        el.style.transform = 'translateY(0)';
      });
    });

  } catch (error) {
    console.error('Error loading artist info:', error);
    // Show fallback info
    E.artistImage.src = '';
    E.artistName.textContent = artistName;
    E.artistYear.textContent = 'Year: -';
    E.artistGenre.textContent = 'Genre: -';
  }
}

/**
 * Get a random song from available songs
 * @returns {Promise<Object>} Random song object
 */
async function getRandomSong() {
  try {
    const response = await fetch('/api/random-song');
    if (!response.ok) throw new Error('Failed to get random song');
    return await response.json();
  } catch (error) {
    console.error('Error getting random song:', error);
    showToast("Failed to load random song");
    return null;
  }
}
  </script>
  <script>
    // Add integration button to full player controls
const integrationButton = document.createElement('button');
integrationButton.className = 'control-button';
integrationButton.innerHTML = '<span class="material-icons">code</span>';
integrationButton.title = 'Get embed code';
document.querySelector('.full-player .player-controls').appendChild(integrationButton);

// Integration state
const integrationState = {
  size: 'normal',
  theme: 'default',
  serverDomain: window.location.origin
};

// Add container to full player
document.getElementById('fullPlayer').insertAdjacentHTML('beforeend', document.getElementById('integrationContainer').outerHTML);

// Integration handling
function initializeIntegration() {
  const container = document.getElementById('integrationContainer');
  const closeBtn = document.getElementById('closeIntegration');
  const copyBtn = document.getElementById('copyCode');
  const sizeBtns = container.querySelectorAll('.size-btn');
  const themeBtns = container.querySelectorAll('.theme-btn');

  // Show integration panel
  integrationButton.addEventListener('click', () => {
    container.style.display = 'block';
    updatePreviewAndCode();
  });

  // Close panel
  closeBtn.addEventListener('click', () => {
    container.style.display = 'none';
  });

  // Size selection
  sizeBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      sizeBtns.forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      integrationState.size = btn.dataset.size;
      updatePreviewAndCode();
    });
  });

  // Theme selection
  themeBtns.forEach(btn => {
    btn.addEventListener('click', () => {
      themeBtns.forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      integrationState.theme = btn.dataset.theme;
      updatePreviewAndCode();
    });
  });

  // Copy code
  copyBtn.addEventListener('click', async () => {
    const code = document.getElementById('embedCode').textContent;
    try {
      await navigator.clipboard.writeText(code);
      copyBtn.innerHTML = '<span class="material-icons">check</span>';
      setTimeout(() => {
        copyBtn.innerHTML = '<span class="material-icons">content_copy</span>';
      }, 2000);
    } catch (err) {
      console.error('Failed to copy:', err);
      showToast('Failed to copy code');
    }
  });
}

document.addEventListener('DOMContentLoaded', async () => {
  try {
    // Load Chart.js first
    await loadScript('https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js');

    // Then load the datalabels plugin
    await loadScript('https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0');

    // Now wait a moment to ensure proper initialization
    await new Promise(resolve => setTimeout(resolve, 100));

    if (window.Chart && window.ChartDataLabels) {
      // Register the plugin
      Chart.register(ChartDataLabels);

      // Set default Chart.js options
      Chart.defaults.font.family = 'sans-serif';
      Chart.defaults.color = '#94a3b8';
      Chart.defaults.elements.line.borderJoinStyle = 'round';
      Chart.defaults.elements.bar.borderRadius = 4;

      await initializeCharts();
      setupInsights();
    } else {
      console.error('Chart.js or ChartDataLabels not properly loaded');
    }
  } catch (err) {
    console.error('Error initializing charts:', err);
  }
});


// Handle window resizing
let resizeTimeout;
window.addEventListener('resize', () => {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(() => {
    if (window.chartInstances) {
      Object.values(window.chartInstances).forEach(chart => {
        if (chart && typeof chart.resize === 'function') {
          chart.resize();
        }
      });
    }
  }, 250);
});

// Helper function to load scripts
function loadScript(src) {
  return new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.src = src;
    script.onload = resolve;
    script.onerror = reject;
    document.head.appendChild(script);
  });
}



// Update preview and code
async function updatePreviewAndCode() {
  if (!state.currentSongId) return;

  const dimensions = {
    small: { width: 320, height: 160 },
    normal: { width: 400, height: 200 },
    large: { width: 500, height: 240 }
  };

  const { width, height } = dimensions[integrationState.size];

  // Update preview iframe
  const previewFrame = document.getElementById('previewFrame');
  previewFrame.style.width = `${width}px`;
  previewFrame.style.height = `${height}px`;

  const embedUrl = `${integrationState.serverDomain}/embed/${state.currentSongId}?size=${integrationState.size}&theme=${integrationState.theme}`;
  previewFrame.src = embedUrl;

  // Generate embed code
  const embedCode = `<iframe
  src="${embedUrl}"
  width="${width}"
  height="${height}"
  frameborder="0"
  allowtransparency="true"
  allow="encrypted-media"
  loading="lazy">
</iframe>`;

  document.getElementById('embedCode').textContent = embedCode;
}

// Initialize integration features
initializeIntegration();

// Update preview when song changes
const originalLoadAndPlay = window.loadAndPlay;
window.loadAndPlay = async function(songId) {
  await originalLoadAndPlay(songId);
  if (document.getElementById('integrationContainer').style.display === 'block') {
    updatePreviewAndCode();
  }
};
async function loadArtistDetails(artistName) {
  try {
    const response = await fetch(`/api/artist-info/${encodeURIComponent(artistName)}`);
    const data = await response.json();

    if (!response.ok) {
      throw new Error(data.error || 'Failed to load artist details');
    }

    // Update description
    document.getElementById('artistDescription').textContent = data.description || 'No description available';

    // Update stats
    document.getElementById('artistSubscribers').textContent = data.stats?.subscribers || '-';
    document.getElementById('artistViews').textContent = data.stats?.views || '-';
    document.getElementById('artistMonthlyListeners').textContent = data.stats?.monthlyListeners || '-';

    // Update top songs
    const topSongsList = document.getElementById('topSongsList');
    topSongsList.innerHTML = '';

    if (data.topSongs && data.topSongs.length > 0) {
      data.topSongs.forEach((song, index) => {
        const songElement = `
          <div class="top-song-item" data-song-id="${song.videoId}">
            <div class="song-number">${index + 1}</div>
            <div class="song-info">
              <div class="song-title">${song.title}</div>
              <div class="song-plays">${song.plays} plays</div>
            </div>
          </div>
        `;
        topSongsList.insertAdjacentHTML('beforeend', songElement);
      });

      // Add click handlers for top songs
      topSongsList.querySelectorAll('.top-song-item').forEach(item => {
        item.addEventListener('click', () => {
          const songId = item.dataset.songId;
          if (songId) {
            loadAndPlay(songId);
          }
        });
      });
    }

    // Update links
    const linksContainer = document.getElementById('artistLinks');
    linksContainer.innerHTML = '';

    if (data.links?.youtube) {
      const youtubeLink = `
        <a href="${data.links.youtube}" target="_blank" rel="noopener noreferrer" class="artist-link">
          <span class="material-icons">play_circle</span>
          YouTube Music
        </a>
      `;
      linksContainer.insertAdjacentHTML('beforeend', youtubeLink);
    }

    if (data.links?.official) {
      const officialLink = `
        <a href="${data.links.official}" target="_blank" rel="noopener noreferrer" class="artist-link">
          <span class="material-icons">language</span>
          Official Website
        </a>
      `;
      linksContainer.insertAdjacentHTML('beforeend', officialLink);
    }

  } catch (error) {
    console.error('Error loading artist details:', error);
    document.getElementById('artistDescription').textContent = 'Failed to load artist details';
  }
}

// Update the existing loadArtistInfo function to also call our new function
const originalLoadArtistInfo = window.loadArtistInfo;
window.loadArtistInfo = async function(artistName) {
  await originalLoadArtistInfo(artistName);
  await loadArtistDetails(artistName);
};
window.onunhandledrejection = function(event) {
    if (event.reason.message.includes('AudioWorklet')) {
        console.warn('AudioWorklet error suppressed:');
        event.preventDefault();
    }
};

  </script>
  <script>
    // Enhanced insights visualization with Chart.js

// Utility for generating gradients
function createGradient(ctx, colorStart, colorEnd) {
  const gradient = ctx.createLinearGradient(0, 0, 0, 300);
  gradient.addColorStop(0, colorStart);
  gradient.addColorStop(1, colorEnd);
  return gradient;
}




// Enhanced initialization with chart responsiveness
document.addEventListener('DOMContentLoaded', () => {
  // Load Chart.js with animation plugin
  Promise.all([
    loadScript('https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js'),
    loadScript('https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0')
  ]).then(() => {
    // Register Chart.js plugins
    Chart.register(ChartDataLabels);

    // Set default Chart.js options for all charts
    Chart.defaults.font.family = 'sans-serif';
    Chart.defaults.color = '#94a3b8';
    Chart.defaults.elements.line.borderJoinStyle = 'round';
    Chart.defaults.elements.bar.borderRadius = 4;
  }).catch(err => {
    console.error('Error loading chart libraries:', err);
    // showToast('Failed to load visualization libraries');
  });
});
// Add insights button to controls
const insightsButton = document.createElement('button');
insightsButton.className = 'control-button';
insightsButton.innerHTML = '<span class="material-icons">insights</span>';
insightsButton.title = 'View Insights';
document.querySelector('.player-controls').appendChild(insightsButton);

// Insights modal handling
const insightsModal = document.getElementById('insightsModal');
const closeInsights = document.getElementById('closeInsights');

insightsButton.addEventListener('click', () => {
  insightsModal.style.display = 'block';
  loadInsights();
});

closeInsights.addEventListener('click', () => {
  insightsModal.style.display = 'none';
});
// Format duration for insights
function formatInsightDuration(seconds) {
  const hours = Math.floor(seconds / 3600);
  const minutes = Math.floor((seconds % 3600) / 60);
  const days = Math.floor(hours / 24);

  if (days > 0) {
    return `${days}d ${hours % 24}h`;
  } else if (hours > 0) {
    return `${hours}h ${minutes}m`;
  }
  return `${minutes}m`;
}

// Helper function to update recent activity
function updateRecentActivity(activities) {
  const recentActivityList = document.getElementById('recentActivityList');
  recentActivityList.innerHTML = activities.map((activity, index) => `
    <div class="activity-item fade-in" style="animation-delay: ${index * 0.05}s">
      <div class="activity-time">${formatRelativeTime(new Date(activity.started_at))}</div>
      <div class="activity-info">
        <div class="activity-title">${activity.title}</div>
        <div class="activity-artist">${activity.artist}</div>
      </div>
      <div class="activity-completion">
        <div class="completion-bar" style="width: ${activity.completion}%"></div>
      </div>
    </div>
  `).join('');
}

// Initialize global chart instances object
window.chartInstances = {
  daily: null,
  hourly: null,
  completion: null
};
const TimeUtils = {
  /**
   * Format time with IST timezone
   * @param {Date|string} date - Date to format
   * @param {boolean} includeDate - Whether to include date in output
   * @returns {string} Formatted time string
   */
  formatTime(date, includeDate = false) {
    if (!date) return '->';

    try {
      const d = new Date(date);
      // Convert to IST
      const istTime = new Date(d.getTime() + (5.5 * 60 * 60 * 1000));

      const options = {
        hour: 'numeric',
        minute: 'numeric',
        hour12: true,
        timeZone: 'Asia/Kolkata'
      };

      if (includeDate) {
        options.day = 'numeric';
        options.month = 'short';
        options.year = 'numeric';
      }

      return istTime.toLocaleString('en-IN', options) + ' IST';
    } catch (e) {
      console.error('Time formatting error:', e);
      return '->';
    }
  },

  /**
   * Format relative time in IST
   * @param {Date|string} date - Date to format
   * @returns {string} Relative time string
   */
  formatRelativeTime(date) {
    if (!date) return 'Unknown time';

    try {
      const now = new Date();
      const then = new Date(date);

      // Convert both to IST
      const istNow = new Date(now.getTime() + (5.5 * 60 * 60 * 1000));
      const istThen = new Date(then.getTime() + (5.5 * 60 * 60 * 1000));

      const diff = istNow - istThen;
      const seconds = Math.floor(diff / 1000);

      if (seconds < 60) return 'just now';
      if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
      if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
      if (seconds < 604800) return `${Math.floor(seconds / 86400)}d ago`;

      return this.formatTime(date, true);
    } catch (e) {
      console.error('Relative time error:', e);
      return 'Unknown time';
    }
  },

  /**
   * Get current IST time
   * @returns {Date} Current time in IST
   */
  getCurrentIST() {
    const now = new Date();
    return new Date(now.getTime() + (5.5 * 60 * 60 * 1000));
  },

  /**
   * Convert UTC to IST
   * @param {Date|string} date - UTC date to convert
   * @returns {Date} IST date
   */
  utcToIST(date) {
    if (!date) return null;
    const d = new Date(date);
    return new Date(d.getTime() + (5.5 * 60 * 60 * 1000));
  }
};

// Modified createDailyChart function
function createDailyChart(dailyData) {
  try {
    const canvas = document.getElementById('dailyPatternChartCanvas');
    if (!canvas) {
      console.error('Daily chart canvas not found');
      return;
    }

    const ctx = canvas.getContext('2d');
    if (!ctx) {
      console.error('Could not get daily chart context');
      return;
    }

    // Clean up existing chart
    if (window.chartInstances.daily) {
      window.chartInstances.daily.destroy();
    }

    const gradient = ctx.createLinearGradient(0, 0, 0, 300);
    gradient.addColorStop(0, 'rgba(79,70,229,0.4)');
    gradient.addColorStop(1, 'rgba(79,70,229,0.1)');

    const labels = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    const data = labels.map((_, i) => dailyData[i] || 0);

    window.chartInstances.daily = new Chart(ctx, {
      type: 'bar',
      data: {
        labels,
        datasets: [{
          data,
          backgroundColor: gradient,
          borderColor: 'rgba(79,70,229,0.8)',
          borderWidth: 2,
          borderRadius: 6,
          barThickness: 'flex',
          maxBarThickness: 25
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: false },
          tooltip: {
            mode: 'index',
            intersect: false,
            callbacks: {
              label: (context) => `${context.parsed.y} plays`
            },
            backgroundColor: 'rgba(15,23,42,0.9)',
            titleColor: '#f8fafc',
            bodyColor: '#94a3b8',
            borderColor: 'rgba(148,163,184,0.1)',
            borderWidth: 1,
            padding: 10,
            displayColors: false
          }
        },
        scales: {
          x: { grid: { display: false }, ticks: { color: '#94a3b8' } },
          y: {
            beginAtZero: true,
            grid: { color: 'rgba(148,163,184,0.1)', drawBorder: false },
            ticks: {
              color: '#94a3b8',
              callback: (value) => value % 1 === 0 ? value : ''
            }
          }
        }
      }
    });
  } catch (error) {
    console.error('Error creating daily chart:', error);
  }
}

// Modified createHourlyChart function
function createHourlyChart(hourlyData) {
  try {
    const canvas = document.getElementById('hourlyPatternChartCanvas');
    if (!canvas) {
      console.error('Hourly chart canvas not found');
      return;
    }

    const ctx = canvas.getContext('2d');
    if (!ctx) {
      console.error('Could not get hourly chart context');
      return;
    }

    // Clean up existing chart
    if (window.chartInstances.hourly) {
      window.chartInstances.hourly.destroy();
    }

    const gradient = ctx.createLinearGradient(0, 0, 0, 300);
    gradient.addColorStop(0, 'rgba(129,140,248,0.4)');
    gradient.addColorStop(1, 'rgba(129,140,248,0.1)');

    const labels = Array.from({length: 24}, (_, i) =>
      `${i.toString().padStart(2, '0')}:00`);
    const data = labels.map((_, i) => hourlyData[i] || 0);

    window.chartInstances.hourly = new Chart(ctx, {
      type: 'line',
      data: {
        labels,
        datasets: [{
          data,
          backgroundColor: gradient,
          borderColor: 'rgba(129,140,248,0.8)',
          borderWidth: 2,
          tension: 0.4,
          fill: true
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: { display: false }
        },
        scales: {
          x: {
            grid: { display: false },
            ticks: {
              color: '#94a3b8',
              maxRotation: 45,
              minRotation: 45,
              callback: (_, index) => index % 3 === 0 ? labels[index] : ''
            }
          },
          y: {
            beginAtZero: true,
            grid: {
              color: 'rgba(148,163,184,0.1)',
              drawBorder: false
            }
          }
        }
      }
    });
  } catch (error) {
    console.error('Error creating hourly chart:', error);
  }
}

// Modified createCompletionChart function
function createCompletionChart(distribution) {
  try {
    const canvas = document.getElementById('completionChartCanvas');
    if (!canvas) {
      console.error('Completion chart canvas not found');
      return;
    }

    const ctx = canvas.getContext('2d');
    if (!ctx) {
      console.error('Could not get completion chart context');
      return;
    }

    // Clean up existing chart
    if (window.chartInstances.completion) {
      window.chartInstances.completion.destroy();
    }

    const total = Object.values(distribution).reduce((a, b) => a + b, 0);
    const data = {
      full: (distribution.full || 0) / total * 100,
      partial: (distribution.partial || 0) / total * 100,
      skip: (distribution.skip || 0) / total * 100
    };

    window.chartInstances.completion = new Chart(ctx, {
      type: 'doughnut',
      data: {
        labels: ['Complete Listen', 'Partial Listen', 'Skipped'],
        datasets: [{
          data: [data.full, data.partial, data.skip],
          backgroundColor: [
            'rgba(79,70,229,0.8)',
            'rgba(129,140,248,0.8)',
            'rgba(199,210,254,0.8)'
          ],
          borderColor: 'transparent'
        }]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
          legend: {
            position: 'bottom',
            labels: {
              color: '#94a3b8',
              padding: 20,
              usePointStyle: true,
              pointStyle: 'circle'
            }
          },
          tooltip: {
            callbacks: (context) => `${context.label}: ${context.parsed.toFixed(1)}%`,
            backgroundColor: 'rgba(15,23,42,0.9)',
            titleColor: '#f8fafc',
            bodyColor: '#94a3b8',
            borderColor: 'rgba(148,163,184,0.1)',
            padding: 10
          }
        },
        cutout: '70%'
      }
    });
  } catch (error) {
    console.error('Error creating completion chart:', error);
  }
}

// Modified createPatternCharts function
function createPatternCharts(patterns) {
  try {
    createDailyChart(patterns.daily);
    createHourlyChart(patterns.hourly);
  } catch (error) {
    console.error('Error creating pattern charts:', error);
  }
}
async function loadInsights() {
  try {
    const response = await fetch('/api/insights');
    const data = await response.json();

    // Helper function to safely update element text
    const setElementText = (id, value) => {
      const element = document.getElementById(id);
      if (element) element.textContent = value;
    };

    // Update basic stats
    setElementText('totalListeningTime', formatInsightDuration(data.overview.total_time));
    setElementText('totalSongs', data.overview.total_songs.toLocaleString());
    setElementText('uniqueArtists', data.overview.unique_artists.toLocaleString());
    setElementText('averageDaily', Math.round(data.overview.average_daily).toString());

    // Update top artists list
    const topArtistsList = document.getElementById('topArtistsList');
    if (topArtistsList && data.top_artists) {
      topArtistsList.innerHTML = data.top_artists.map((artist, index) => `
        <div class="artist-card fade-in" style="animation-delay: ${index * 0.1}s">
          <div class="artist-rank">#${index + 1}</div>
          <div class="artist-info">
            <div class="artist-name">${artist.name}</div>
            <div class="artist-stats">
              ${artist.plays.toLocaleString()} plays • ${formatInsightDuration(artist.time)}
            </div>
          </div>
        </div>
      `).join('');
    }

    // Initialize charts
    if (!window.Chart) {
      await loadScript('https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js');
    }

    // Create/update charts
    await initializeCharts();

    if (data.listening_patterns) {
      createPatternCharts(data.listening_patterns);
    }

    if (data.completion_rates?.completion_distribution) {
      createCompletionChart(data.completion_rates.completion_distribution);
    }

    // Update recent activity
    if (data.recent_activity) {
      const recentActivityList = document.getElementById('recentActivityList');
      if (recentActivityList) {
        recentActivityList.innerHTML = data.recent_activity.map((activity, index) => `
          <div class="activity-item fade-in" style="animation-delay: ${index * 0.05}s">

            <div class="activity-info">
              <div class="activity-title">${activity.title}</div>
              <div class="activity-artist">${activity.artist}</div>
            </div>
            <div class="activity-completion">
              <div class="completion-bar" style="width: ${activity.completion}%"></div>
            </div>
          </div>
        `).join('');
      }
    }

    // Update completion rate
    if (data.completion_rates?.average_completion) {
      setElementText('averageCompletion', `${data.completion_rates.average_completion.toFixed(1)}%`);
    }

  } catch (error) {
    console.error('Error loading insights:', error);
    showToast('Failed to load insights');
  }
}
function updateInsightElements(data) {
  // Helper function to safely update element text
  const setElementText = (id, value) => {
    const element = document.getElementById(id);
    if (element) element.textContent = value;
  };

  // Helper for creating artist cards
  const createArtistCard = (artist, index) => `
    <div class="artist-card fade-in" style="animation-delay: ${index * 0.1}s">
      <div class="artist-rank">#${index + 1}</div>
      <div class="artist-info">
        <div class="artist-name">${artist.name}</div>
        <div class="artist-stats">
          ${artist.plays.toLocaleString()} plays • ${formatInsightDuration(artist.time)}
        </div>
      </div>
    </div>
  `;

  // Helper for creating activity items
  const createActivityItem = (activity, index) => `
    <div class="activity-item fade-in" style="animation-delay: ${index * 0.05}s">
      <div class="activity-time">${formatRelativeTime(new Date(activity.started_at))}</div>
      <div class="activity-info">
        <div class="activity-title">${activity.title}</div>
        <div class="activity-artist">${activity.artist}</div>
      </div>
      <div class="activity-completion">
        <div class="completion-bar" style="width: ${activity.completion}%"></div>
      </div>
    </div>
  `;

  // Update overview stats
  setElementText('totalListeningTime', formatInsightDuration(data.overview.total_time));
  setElementText('totalSongs', data.overview.total_songs.toLocaleString());
  setElementText('uniqueArtists', data.overview.unique_artists.toLocaleString());
  setElementText('averageDaily', Math.round(data.overview.average_daily).toString());

  // Update top artists
  const topArtistsList = document.getElementById('topArtistsList');
  if (topArtistsList && data.top_artists) {
    topArtistsList.innerHTML = data.top_artists.map(createArtistCard).join('');
  }

  // Update recent activity
  const recentActivityList = document.getElementById('recentActivityList');
  if (recentActivityList && data.recent_activity) {
    recentActivityList.innerHTML = data.recent_activity.map(createActivityItem).join('');
  }

  // Update completion rate
  if (data.completion_rates?.average_completion) {
    setElementText('averageCompletion', `${data.completion_rates.average_completion.toFixed(1)}%`);
  }
}
function createActivityItem(activity, index) {
  const activityDate = new Date(activity.started_at);
  const formattedTime = formatRelativeTime(activityDate);

  return `
    <div class="activity-item fade-in" style="animation-delay: ${index * 0.05}s">
      <div class="activity-time">${formattedTime}</div>
      <div class="activity-info">
        <div class="activity-title">${activity.title}</div>
        <div class="activity-artist">${activity.artist}</div>
      </div>
      <div class="activity-completion">
        <div class="completion-bar" style="width: ${activity.completion}%"></div>
      </div>
    </div>
  `;
}

let currentListenId = null;
let currentSessionId = null;

async function startListeningSession(songId, title, artist) {
  try {
    const response = await fetch('/api/listen/start', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ songId, title, artist })
    });
    const data = await response.json();
    currentListenId = data.listenId;
    currentSessionId = data.sessionId;
  } catch (error) {
    console.error('Failed to start listening session:', error);
  }
}

async function endListeningSession(duration, listenedDuration) {
  if (!currentListenId) return;

  try {
    await fetch('/api/listen/end', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        listenId: currentListenId,
        duration,
        listenedDuration
      })
    });
  } catch (error) {
    console.error('Failed to end listening session:', error);
  } finally {
    currentListenId = null;
  }
}
  </script>
  <script>
    if ('mediaSession' in navigator) {
  navigator.mediaSession.metadata = new MediaMetadata({
    title: '',
    artist: '',
    artwork: []
  });

  navigator.mediaSession.setActionHandler('play', () => {
    togglePlay();
  });
  navigator.mediaSession.setActionHandler('pause', () => {
    togglePlay();
  });
  navigator.mediaSession.setActionHandler('previoustrack', () => {
    playPrevious();
  });
  navigator.mediaSession.setActionHandler('nexttrack', () => {
    playNext();
  });
}
// Add history button to controls
const historyButton = document.createElement('button');
historyButton.className = 'control-button';
historyButton.innerHTML = '<span class="material-icons">history</span>';
historyButton.title = 'View History';
document.querySelector('.player-controls').appendChild(historyButton);

const historyModal = document.getElementById('historyModal');
const closeHistory = document.getElementById('closeHistory');
const historyList = document.getElementById('historyList');

historyButton.addEventListener('click', () => {
    historyModal.style.display = 'block';
    loadHistory();
});

closeHistory.addEventListener('click', () => {
    historyModal.style.display = 'none';
});
class ImageLoader {
  constructor() {
    this.cache = new Map();
    this.corsEnabled = new Set();  // Track which domains support CORS
  }

  async loadImage(url, retryWithNoCors = true) {
    if (this.cache.has(url)) {
      return this.cache.get(url);
    }

    // For YouTube thumbnails, modify URL to use img.youtube.com
    if (url.includes('i.ytimg.com')) {
      url = url.replace('i.ytimg.com', 'img.youtube.com');
    }

    try {
      const imgUrl = await this.loadWithFallback(url, retryWithNoCors);
      this.cache.set(url, imgUrl);
      return imgUrl;
    } catch (error) {
      console.warn(`Failed to load image: ${url}`, error);
      return '/static/images/default-cover.jpg';
    }
  }

  async loadWithFallback(url, retryWithNoCors) {
    // Try loading with proxy first for known non-CORS domains
    if (!this.corsEnabled.has(new URL(url).hostname)) {
      try {
        const proxyUrl = `/api/proxy/image?url=${encodeURIComponent(url)}`;
        const response = await fetch(proxyUrl);
        if (response.ok) {
          const blob = await response.blob();
          return URL.createObjectURL(blob);
        }
      } catch (error) {
        console.warn('Proxy fetch failed, trying direct:', error);
      }
    }

    // Try direct load with CORS
    try {
      const response = await fetch(url, { mode: 'cors' });
      if (response.ok) {
        this.corsEnabled.add(new URL(url).hostname);
        const blob = await response.blob();
        return URL.createObjectURL(blob);
      }
    } catch (error) {
      console.warn('CORS fetch failed:', error);
    }

    // Last resort: return original URL for <img> to handle
    if (retryWithNoCors) {
      return url;
    }

    throw new Error('All image loading attempts failed');
  }
}

// Create a single instance for use throughout the app
const imageLoader = new ImageLoader();
// Update the ImageCache class with better CORS handling
class ImageCache {
  constructor() {
    this.cache = new Map();
    this.retryCount = new Map();
    this.maxRetries = 4;
    this.initLocalStorage();
  }

  async loadImage(url, fallbackUrl = '/static/images/default-cover.jpg') {
    try {
      // First try memory cache
      if (this.cache.has(url)) {
        return this.cache.get(url);
      }

      // Then check localStorage cache
      const cacheData = JSON.parse(localStorage.getItem('imageCacheData') || '{}');
      if (cacheData[url] && Date.now() - cacheData[url].timestamp < 24 * 60 * 60 * 1000) {
        return cacheData[url].dataUrl;
      }

      // Try loading with CORS mode first
      const img = new Image();
      img.crossOrigin = 'anonymous';
      img.src = url;

      const imageData = await new Promise((resolve, reject) => {
        img.onload = () => {
          const canvas = document.createElement('canvas');
          canvas.width = img.width;
          canvas.height = img.height;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0);
          resolve(canvas.toDataURL('image/jpeg'));
        };
        img.onerror = () => reject(new Error('Image load failed'));
      });

      // Cache the successful result
      this.cache.set(url, imageData);
      cacheData[url] = {
        dataUrl: imageData,
        timestamp: Date.now()
      };
      localStorage.setItem('imageCacheData', JSON.stringify(cacheData));

      return imageData;

    } catch (error) {
      // If first attempt fails, try without CORS
      try {
        const response = await fetch(url, {
          mode: 'no-cors',
          cache: 'force-cache'
        });
        return url; // Return original URL if no-cors succeeds
      } catch (e) {
        console.warn(`Image load error for ${url}:`, e);
        return fallbackUrl;
      }
    }
  }

  initLocalStorage() {
    if (!localStorage.getItem('imageCacheData')) {
      localStorage.setItem('imageCacheData', JSON.stringify({}));
    }
    this.clearOldCache();
  }

  clearOldCache() {
    const cacheData = JSON.parse(localStorage.getItem('imageCacheData') || '{}');
    const now = Date.now();
    const oneDay = 24 * 60 * 60 * 1000;

    Object.keys(cacheData).forEach(key => {
      if (now - cacheData[key].timestamp > oneDay) {
        delete cacheData[key];
      }
    });

    localStorage.setItem('imageCacheData', JSON.stringify(cacheData));
  }

  blobToDataUrl(blob) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  }
}
async function loadHistory() {
  const historyList = document.getElementById('historyList');
  if (!historyList) return;

  historyList.innerHTML = Array(5).fill(0).map(() => `
    <div class="history-item skeleton">
      <div class="history-thumbnail skeleton"></div>
      <div class="history-info skeleton"></div>
    </div>
  `).join('');

  try {
    const response = await fetch('/api/queue');
    if (!response.ok) throw new Error('Failed to fetch history');
    const history = await response.json();

    const loadedHistory = await Promise.all(history.map(async item => {
      let thumbnailUrl = '/static/images/default-cover.jpg';

      if (item.thumbnail) {
        thumbnailUrl = await imageLoader.loadImage(item.thumbnail);
      } else if (!item.id.startsWith('local-')) {
        thumbnailUrl = await imageLoader.loadImage(
          `https://img.youtube.com/vi/${item.id}/hqdefault.jpg`
        );
      }

      // Format played_at time in IST
      const playedTime = TimeUtils.formatTime(item.played_at, true);

      return `
        <div class="history-item" data-id="${item.id}">
          <img class="history-thumbnail"
               src="${thumbnailUrl}"
               alt="${item.title}"
               loading="lazy">
          <div class="history-info">
            <div class="history-title">${item.title || 'Unknown Title'}</div>
            <div class="history-artist">${item.artist || 'Unknown Artist'}</div>
            <div class="history-time">${playedTime}</div>
          </div>
          <div class="history-play">
            <span class="material-icons">play_arrow</span>
          </div>
        </div>
      `;
    }));

    historyList.innerHTML = loadedHistory.join('');

    // Add click handlers
    document.querySelectorAll('.history-item').forEach(item => {
      item.addEventListener('click', () => {
        const songId = item.dataset.id;
        loadAndPlay(songId);
        document.getElementById('historyModal').style.display = 'none';
      });
    });

  } catch (error) {
    console.error('Error loading history:', error);
    historyList.innerHTML = `
      <div class="history-error">
        <span class="material-icons">error_outline</span>
        <p>Failed to load history. Please try again later.</p>
      </div>
    `;
  }
}
// Hamburger Menu Component
const hamburgerMenuHTML = `
<div class="hamburger-menu">
  <button class="hamburger-button">
    <span class="material-icons">menu</span>
  </button>
  <div class="menu-content">
    <div class="menu-header">
      <h3>Sangeet Premium</h3>
      <button class="close-menu" style="
  padding: 0;
  background-color: #ff5f57;
  border: none;
  border-radius: 50%;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 20px;
  height: 20px;
  position: relative;
  &:hover {
    background-color: #ff7369;
  }
  &:active {
    background-color: #e04942;
    transform: scale(0.95);
  }
">
  <!-- Dot that transforms to minus -->
  <div style="
    width: 6px;
    height: 6px;
    background-color: rgba(0, 0, 0, 0.4);
    border-radius: 50%;
    transition: all 0.2s ease;
    position: absolute;
    &:hover {
      width: 8px;
      height: 2px;
      border-radius: 1px;
    }
  "></div>
</button>
    </div>
    <div class="menu-items">
      <button class="menu-item" data-action="history">
        <span class="material-icons">history</span>
        <span>History</span>
      </button>
      <button class="menu-item" data-action="insights">
        <span class="material-icons">insights</span>
        <span>Insights</span>
      </button>
       <button onclick="window.location.href='/logout'" style="
        background: linear-gradient(135deg, #3b82f6, #2563eb);
        color: white;
        border: none;
        padding: 15px 40px;
        font-size: 18px;
        border-radius: 50px;
        cursor: pointer;
        font-family: Arial, sans-serif;
        font-weight: bold;
        display: flex;
        align-items: center;
        gap: 10px;
        box-shadow: 0 4px 15px rgba(59, 130, 246, 0.5);
        transition: transform 0.2s, box-shadow 0.2s;
        text-transform: uppercase;
        letter-spacing: 1px;
        outline: none;
    " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(59, 130, 246, 0.6)'"
    onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(59, 130, 246, 0.5)'">
        <i class="fas fa-sign-out-alt"></i>
        Logout Sangeet
    </button>
      <button
        onclick="window.open('/get-extension', '_blank')"
        style="
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(45deg, #4CAF50, #81C784);
            color: white;
            font-size: 16px;
            font-weight: bold;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2), 0 1px 3px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease-in-out;
        "
        onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 10px rgba(0, 0, 0, 0.25), 0 2px 4px rgba(0, 0, 0, 0.15)';"
        onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 6px rgba(0, 0, 0, 0.2), 0 1px 3px rgba(0, 0, 0, 0.1)';"
    >
        <span class="material-icons" style="margin-right: 8px; font-size: 20px;">extension</span>
        Get Extension
    </button>
    <a href="https://github.com/easy-ware/Sangeet-Premium" target="_blank" class="glass-button">
    <svg class="source-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/>
    </svg>
    <span class="button-text">Get Source</span>
    <div class="sparkle" style="top: 20%; left: 10%"></div>
    <div class="sparkle" style="top: 60%; left: 80%"></div>
    <div class="sparkle" style="top: 30%; left: 60%"></div>
  </a>

<div style="
  position: relative;
  text-align: center;
  min-height: 200px;
  overflow: hidden;
  padding: 20px;
  background: linear-gradient(135deg, #1e1e2f, #2d2d44);
">
  <h1 style="
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    color: white;
    background: linear-gradient(45deg, #ff3366, #ff6b6b);
    padding: 30px;
    border-radius: 15px;
    text-align: center;
    text-transform: uppercase;
    letter-spacing: 3px;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    position: relative;
    z-index: 1;
    transition: transform 0.3s ease;
  " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
    Sangeet Premium
    <span style="
      display: block;
      font-size: 16px;
      margin-top: 10px;
      font-weight: 300;
      text-transform: none;
      opacity: 0.9;
    ">Version v1.2.0</span>
  </h1>

  <!-- Animated Music Notes -->
  <div class="music-note" style="left: 10%; animation-delay: 0s;">♪</div>
  <div class="music-note" style="left: 20%; animation-delay: 0.5s;">♫</div>
  <div class="music-note" style="right: 15%; animation-delay: 1s;">♬</div>
  <div class="music-note" style="right: 25%; animation-delay: 1.5s;">♪</div>
</div>


    </div>
  </div>
</div>
`;

// Add these styles to your CSS
const hamburgerStyles = `
.hamburger-menu {
  position: fixed;
  top: 1rem;
  right: 1rem;
  z-index: 1000;
}

.hamburger-button {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: var(--accent-gradient);
  border: none;
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  box-shadow: 0 2px 10px rgba(0,0,0,0.2);
  transition: all 0.3s ease;
}

.hamburger-button:hover {
  transform: scale(1.1);
}

.menu-content {
  position: fixed;
  top: 0;
  right: -300px;
  width: 300px;
  height: 100vh;
  background: var(--surface-color);
  box-shadow: -5px 0 20px rgba(0,0,0,0.3);
  transition: right 0.3s ease;
  display: flex;
  flex-direction: column;
  overflow-y:scroll;
}
.menu-content::-webkit-scrollbar{
    width:0;
}

.menu-content.active {
  right: 0;
}

.menu-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem;
  border-bottom: 1px solid rgba(255,255,255,0.1);
}

.menu-items {
  padding: 1rem;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.menu-item {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 1rem;
  border-radius: 12px;
  background: none;
  border: none;
  color: var(--text-primary);
  cursor: pointer;
  transition: all 0.3s ease;
  width: 100%;
  text-align: left;
}

.menu-item:hover {
  background: var(--card-color);
  transform: translateX(5px);
}

.menu-item .material-icons {
  color: var(--primary-light);
}

/* Skeleton Loading Styles */
.skeleton-loading {
  animation: skeletonPulse 1.5s infinite;
  background: linear-gradient(90deg, var(--surface-color) 25%, var(--card-color) 50%, var(--surface-color) 75%);
  background-size: 200% 100%;
  border-radius: 8px;
}

@keyframes skeletonPulse {
  0% { background-position: -200% 0; }
  100% { background-position: 200% 0; }
}

.history-item.skeleton {
  opacity: 0.7;
}

.history-thumbnail.skeleton {
  background: var(--card-color);
}

.history-info.skeleton::before {
  content: '';
  display: block;
  width: 70%;
  height: 20px;
  background: var(--card-color);
  margin-bottom: 8px;
  border-radius: 4px;
}
`;


function initHamburgerMenu() {
  document.body.insertAdjacentHTML('beforeend', hamburgerMenuHTML);

  const hamburgerButton = document.querySelector('.hamburger-button');
  const menuContent = document.querySelector('.menu-content');
  const closeMenu = document.querySelector('.close-menu');

  // Close menu function
  const closeMenuFunc = () => {
    menuContent.classList.remove('active');
  };

  hamburgerButton.addEventListener('click', (e) => {
    e.stopPropagation(); // Prevent click from immediately closing menu
    menuContent.classList.add('active');
  });

  closeMenu.addEventListener('click', closeMenuFunc);

  // Close when clicking outside
  document.addEventListener('click', (e) => {
    if (menuContent.classList.contains('active') &&
        !menuContent.contains(e.target) &&
        !hamburgerButton.contains(e.target)) {
      closeMenuFunc();
    }
  });

  // Prevent closing when clicking inside menu
  menuContent.addEventListener('click', (e) => {
    e.stopPropagation();
  });

  // Handle menu items
  document.querySelectorAll('.menu-item').forEach(item => {
    item.addEventListener('click', () => {
      const action = item.dataset.action;
      closeMenuFunc();

      switch(action) {
        case 'history':
          document.getElementById('historyModal').style.display = 'block';
          loadHistory();
          break;
        case 'insights':
          document.getElementById('insightsModal').style.display = 'block';
          loadInsights();
          break;
        case 'downloads':
          // Handle downloads view
          break;
      }
    });
  });
}

// Add styles to document
const style = document.createElement('style');
style.textContent = hamburgerStyles;
document.head.appendChild(style);

// Initialize on page load
document.addEventListener('DOMContentLoaded', () => {
  initHamburgerMenu();
});
const historyStyles = `
.history-error {
    text-align: center;
    padding: 2rem;
    color: var(--text-secondary);
}

.history-error .material-icons {
    font-size: 3rem;
    margin-bottom: 1rem;
    color: var(--error-color);
}

.history-item {
    display: flex;
    align-items: center;
    padding: 1rem;
    border-radius: 12px;
    margin-bottom: 1rem;
    background: var(--surface-color);
    transition: all 0.3s ease;
    cursor: pointer;
}

.history-item:hover {
    background: var(--card-color);
    transform: translateY(-2px);
}

.history-thumbnail {
    width: 60px;
    height: 60px;
    border-radius: 8px;
    margin-right: 1rem;
    object-fit: cover;
    background-color: var(--card-color);
}

.history-play {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: var(--accent-gradient);
    display: flex;
    align-items: center;
    justify-content: center;
    margin-left: 1rem;
    opacity: 0;
    transition: all 0.3s ease;
}

.history-time {
    color: var(--text-secondary);
    font-size: 0.8rem;
    margin-top: 0.25rem;
}
`;

// Add styles to document
const styleSheet = document.createElement('style');
styleSheet.textContent = historyStyles;
document.head.appendChild(styleSheet);
// Update chart initialization

// Update createPatternCharts function with better error handling
function createPatternCharts(patterns) {
  if (!patterns) return;

  const dailyCanvas = document.getElementById('dailyPatternChartCanvas');
  const hourlyCanvas = document.getElementById('hourlyPatternChartCanvas');

  if (dailyCanvas && patterns.daily) {
    createDailyChart(patterns.daily);
  }
  if (hourlyCanvas && patterns.hourly) {
    createHourlyChart(patterns.hourly);
  }
}
function createActivityItem(activity, index) {
  const timestamp = TimeUtils.formatRelativeTime(activity.started_at);

  return `
    <div class="activity-item fade-in" style="animation-delay: ${index * 0.05}s">
      <div class="activity-time">${timestamp}</div>
      <div class="activity-info">
        <div class="activity-title">${activity.title}</div>
        <div class="activity-artist">${activity.artist}</div>
      </div>
      <div class="activity-completion">
        <div class="completion-bar" style="width: ${activity.completion}%"></div>
      </div>
    </div>
  `;
}
// Time formatting utilities
const TimeFormatter = {
  /**
   * Format seconds to MM:SS or HH:MM:SS
   * @param {number} seconds - Time in seconds
   * @returns {string} Formatted time string
   */
  formatTime(seconds) {
    if (!seconds || isNaN(seconds)) {
      seconds = 0;
    }

    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);

    if (hours > 0) {
      return `${hours}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
    }
    return `${minutes}:${String(secs).padStart(2, '0')}`;
  },

  /**
   * Format time with IST timezone
   * @param {Date|string} date - Date to format
   * @param {boolean} includeDate - Whether to include date in output
   * @returns {string} Formatted time string
   */
  formatDateTime(date, includeDate = false) {
    if (!date) return '->';

    try {
      const d = new Date(date);
      // Convert to IST
      const istTime = new Date(d.getTime() + (5.5 * 60 * 60 * 1000));

      const options = {
        hour: 'numeric',
        minute: 'numeric',
        hour12: true,
        timeZone: 'Asia/Kolkata'
      };

      if (includeDate) {
        options.day = 'numeric';
        options.month = 'short';
        options.year = 'numeric';
      }

      return istTime.toLocaleString('en-IN', options) ;
    } catch (e) {
      console.error('Time formatting error:', e);
      return '->';
    }
  },

  /**
   * Format relative time in IST
   * @param {Date|string} date - Date to format
   * @returns {string} Relative time string
   */
  formatRelativeTime(date) {
    if (!date) return 'Unknown time';

    try {
      const now = new Date();
      const then = new Date(date);

      // Convert both to IST
      const istNow = new Date(now.getTime() + (5.5 * 60 * 60 * 1000));
      const istThen = new Date(then.getTime() + (5.5 * 60 * 60 * 1000));

      const diff = istNow - istThen;
      const seconds = Math.floor(diff / 1000);

      if (seconds < 60) return 'just now';
      if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
      if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
      if (seconds < 604800) return `${Math.floor(seconds / 86400)}d ago`;

      return this.formatDateTime(date, true);
    } catch (e) {
      console.error('Relative time error:', e);
      return 'Unknown time';
    }
  },

  /**
   * Format duration for insights
   * @param {number} seconds - Duration in seconds
   * @returns {string} Formatted duration string
   */
  formatDuration(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const days = Math.floor(hours / 24);

    if (days > 0) {
      return `${days}d ${hours % 24}h`;
    } else if (hours > 0) {
      return `${hours}h ${minutes}m`;
    }
    return `${minutes}m`;
  }
};

// Make formatTime available globally
window.formatTime = TimeFormatter.formatTime;
window.formatDateTime = TimeFormatter.formatDateTime;
window.formatRelativeTime = TimeFormatter.formatRelativeTime;
window.formatDuration = TimeFormatter.formatDuration;
  </script>
  <script>
    // Add hover effect to music notes
    document.querySelectorAll('.music-note').forEach(note => {
      setInterval(() => {
        note.style.left = Math.random() * 80 + 10 + '%';
      }, 3000);
    });
  </script>
  <script>
    // Create a notification manager class
class NotificationManager {
  constructor() {
    this.init();
  }

  init() {
    // Create container for notifications
    const container = document.createElement('div');
    container.className = 'notification-container';
    document.body.appendChild(container);

    // Add styles
    const styles = document.createElement('style');
    styles.textContent = `
      .notification-container {
        position: fixed;
        top: 20px;
        left: 20px;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        gap: 10px;
        max-width: 320px;
      }

      .notification {
        background: var(--surface-color);
        border-left: 4px solid;
        border-radius: 8px;
        padding: 16px;
        color: var(--text-primary);
        display: flex;
        align-items: flex-start;
        gap: 12px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        transform-origin: left;
        animation: slideIn 0.3s ease forwards;
        cursor: pointer;
        position: relative;
        overflow: hidden;
        transition: all 0.3s ease;
      }

      .notification.removing {
        animation: slideOut 0.3s ease forwards;
      }

      .notification:hover {
        transform: translateX(5px);
      }

      .notification-icon {
        font-size: 20px;
        flex-shrink: 0;
      }

      .notification-content {
        flex-grow: 1;
        padding-right: 20px;
      }

      .notification-title {
        font-weight: 600;
        margin-bottom: 4px;
      }

      .notification-message {
        font-size: 0.9rem;
        opacity: 0.9;
      }

      .notification-close {
        position: absolute;
        top: 8px;
        right: 8px;
        padding: 4px;
        border-radius: 50%;
        cursor: pointer;
        opacity: 0.6;
        transition: all 0.2s;
        background: none;
        border: none;
        color: inherit;
      }

      .notification-close:hover {
        opacity: 1;
        background: rgba(255,255,255,0.1);
      }

      .notification-progress {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 3px;
        background: rgba(255,255,255,0.1);
      }

      .notification-progress-bar {
        height: 100%;
        background: currentColor;
        transition: width linear;
      }

      /* Types */
      .notification.success {
        background: rgba(34,197,94,0.1);
        border-color: #22c55e;
        color: #22c55e;
      }

      .notification.error {
        background: rgba(239,68,68,0.1);
        border-color: #ef4444;
        color: #ef4444;
      }

      .notification.warning {
        background: rgba(234,179,8,0.1);
        border-color: #eab308;
        color: #eab308;
      }

      .notification.info {
        background: rgba(59,130,246,0.1);
        border-color: #3b82f6;
        color: #3b82f6;
      }

      @keyframes slideIn {
        from {
          transform: translateX(-100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      @keyframes slideOut {
        from {
          transform: translateX(0);
          opacity: 1;
        }
        to {
          transform: translateX(-100%);
          opacity: 0;
        }
      }
    `;
    document.head.appendChild(styles);
  }

  show({ title, message, type = 'info', duration = 5000 }) {
    const container = document.querySelector('.notification-container');
    const notification = document.createElement('div');

    // Set notification content
    notification.className = `notification ${type}`;
    notification.innerHTML = `
      <div class="notification-icon">
        <span class="material-icons">
          ${this.getIcon(type)}
        </span>
      </div>
      <div class="notification-content">
        <div class="notification-title">${title}</div>
        <div class="notification-message">${message}</div>
      </div>
      <button class="notification-close">
        <span class="material-icons">close</span>
      </button>
      <div class="notification-progress">
        <div class="notification-progress-bar"></div>
      </div>
    `;

    // Add to container
    container.appendChild(notification);

    // Setup progress bar
    const progressBar = notification.querySelector('.notification-progress-bar');
    progressBar.style.width = '100%';
    progressBar.style.transitionDuration = `${duration}ms`;

    // Start progress
    requestAnimationFrame(() => {
      progressBar.style.width = '0%';
    });

    // Setup close button
    const closeBtn = notification.querySelector('.notification-close');
    closeBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      this.remove(notification);
    });

    // Setup swipe to dismiss
    let startX = 0;
    let currentX = 0;

    notification.addEventListener('touchstart', (e) => {
      startX = e.touches[0].clientX;
    });

    notification.addEventListener('touchmove', (e) => {
      currentX = e.touches[0].clientX;
      const diff = currentX - startX;
      if (diff < 0) {
        notification.style.transform = `translateX(${diff}px)`;
      }
    });

    notification.addEventListener('touchend', () => {
      const diff = currentX - startX;
      if (diff < -100) {
        this.remove(notification);
      } else {
        notification.style.transform = '';
      }
    });

    // Auto remove after duration
    if (duration) {
      setTimeout(() => {
        if (container.contains(notification)) {
          this.remove(notification);
        }
      }, duration);
    }
  }

  remove(notification) {
    notification.classList.add('removing');
    setTimeout(() => {
      notification.remove();
    }, 300);
  }

  getIcon(type) {
    switch(type) {
      case 'success': return 'check_circle';
      case 'error': return 'error';
      case 'warning': return 'warning';
      case 'info': return 'info';
      default: return 'info';
    }
  }
}

// Create global instance
window.notifications = new NotificationManager();

// Usage examples:
function showNotification(type, title, message, duration = 5000) {
  window.notifications.show({
    type,
    title,
    message,
    duration
  });
}
//usage
// Show different types of notifications
// showNotification('success', 'Success!', 'Operation completed successfully');
// showNotification('error', 'Error!', 'Something went wrong');
// showNotification('warning', 'Warning', 'Please backup before proceeding');
// showNotification('info', 'Info', 'New update available');

// // With custom duration (in milliseconds)
// showNotification('info', 'Quick Note', 'This will disappear in 2 seconds', 2000);
  </script>
  <script>
 // Add enhanced progress loading styles
const progressLoadingStyles = document.createElement('style');
progressLoadingStyles.textContent = `
  /* Progress Skeleton Loading Styles */
  .progress-skeleton {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(
      90deg,
      var(--surface-color) 25%,
      var(--card-color) 50%,
      var(--surface-color) 75%
    );
    background-size: 200% 100%;
    animation: shimmer 1.5s infinite;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
  }

  /* Progress Bar Loading State */
  .progress-bar.loading {
    height: 12px;
    opacity: 0.3;
    transition: all 0.3s ease;
  }

  /* Progress Bar Loading Animation */
  @keyframes shimmer {
    0% { background-position: -200% 0; }
    100% { background-position: 200% 0; }
  }

  /* Time Indicator Loading State */
  .time-indicator.loading {
    opacity: 0.5;
    animation: pulse 1.5s infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 0.5; }
    50% { opacity: 0.2; }
  }

  /* Mobile Specific Progress Bar Adjustments */
  @media (max-width: 768px) {
    .progress-bar.loading {
      height: 14px;
    }
  }
`;
document.head.appendChild(progressLoadingStyles);

// Enhanced progress loading management
function enhanceProgressLoading() {
    const audio = E.audio;
    const miniProgress = E.progressBar;
    const fullProgress = E.fullProgressBar;
    const progressSkeleton = E.progressSkeleton;
    const timeIndicators = document.querySelectorAll('.time-indicator');
    const progressBars = document.querySelectorAll('.progress-bar');

    function showLoading() {
        progressSkeleton.style.opacity = "1";
        progressBars.forEach(bar => bar.classList.add('loading'));
        timeIndicators.forEach(indicator => indicator.classList.add('loading'));
    }

    function hideLoading() {
        progressSkeleton.style.opacity = "0";
        progressBars.forEach(bar => bar.classList.remove('loading'));
        timeIndicators.forEach(indicator => indicator.classList.remove('loading'));
    }

    // Show loading on audio events
    audio.addEventListener('loadstart', showLoading);
    audio.addEventListener('waiting', showLoading);
    audio.addEventListener('seeking', showLoading);
    audio.addEventListener('stalled', showLoading);

    // Hide loading when ready
    audio.addEventListener('canplay', hideLoading);
    audio.addEventListener('playing', hideLoading);
    audio.addEventListener('seeked', hideLoading);

    // Handle errors
    audio.addEventListener('error', () => {
        hideLoading();
        showToast('error', 'Playback Error', 'Failed to load audio. Please try again.');
    });

    // Modify setupInitialSong to show loading state immediately
    const originalSetupInitialSong = window.setupInitialSong;
    window.setupInitialSong = async function() {
        showLoading(); // Show loading immediately
        try {
            await originalSetupInitialSong.apply(this, arguments);
        } catch (error) {
            console.error('Setup initial song error:', error);
            hideLoading();
        }
    };

    // Show loading state initially if not ready
    if (audio.readyState < 3) {
        showLoading();
    }
}

// Initialize the enhanced progress loading
document.addEventListener('DOMContentLoaded', enhanceProgressLoading);
  </script>
  <script>
    //  async function setFavicons() {
      //       const response = await fetch('/data/download/icons/sangeet-home');
      //       const data = await response.json();
      //       const base64Data = data.base64;

      //       const sizes = [16, 32, 48, 64, 128, 256];
      //       sizes.forEach(size => {
      //           const link = document.createElement('link');
      //           link.rel = 'icon';
      //           link.type = 'image/png';
      //           link.sizes = `${size}x${size}`;
      //           link.href = `data:image/png;base64,${base64Data}`;
      //           document.head.appendChild(link);
      //       });
      //   }

      //   // Call the function to set favicons
      //   setFavicons();
      // async function setGifFavicon() {
      //       const response = await fetch('/data/download/icons/sangeet-home'); // Adjust the route as needed
      //       const data = await response.json();
      //       const base64Gif = data.base64;

      //       // Define common sizes for favicons
      //       const sizes = [16, 32, 48, 64, 128, 256];

      //       // Clear any existing favicons
      //       const existingFavicons = document.querySelectorAll('link[rel="icon"]');
      //       existingFavicons.forEach(favicon => favicon.remove());

      //       // Add new favicons for each size
      //       sizes.forEach(size => {
      //           const link = document.createElement('link');
      //           link.rel = 'icon';
      //           link.type = 'image/gif';
      //           link.sizes = `${size}x${size}`;
      //           link.href = `data:image/gif;base64,${base64Gif}`;
      //           document.head.appendChild(link);
      //       });
      //   }

      //   // Call the function to set the GIF favicon
      //   setGifFavicon();
  </script>
  <script>

// Enhanced progress bar touch handling
function setupProgressBar(container, progressHover, callback) {
  if (!container || !progressHover) return;

  let isDragging = false;
  let touchStartX = 0;
  let lastUpdateTime = 0;
  const updateThreshold = 50; // Minimum time between updates in ms

  // Touch start handler
  container.addEventListener("touchstart", (e) => {
    e.preventDefault();
    isDragging = true;
    touchStartX = e.touches[0].clientX;

    // Show visual feedback
    container.querySelector('.progress-bar').style.height =
      window.innerWidth <= 768 ? '14px' : '12px';
  });

  // Enhanced touch move handler with throttling
  container.addEventListener("touchmove", (e) => {
    if (!isDragging) return;

    const currentTime = Date.now();
    if (currentTime - lastUpdateTime < updateThreshold) return;

    const touch = e.touches[0];
    const rect = container.getBoundingClientRect();
    const percent = Math.max(0, Math.min(1, (touch.clientX - rect.left) / rect.width));

    progressHover.style.width = `${percent * 100}%`;

    if (E.audio.duration) {
      E.audio.currentTime = E.audio.duration * percent;
      lastUpdateTime = currentTime;
    }
  }, { passive: false });

  // Touch end handler
  container.addEventListener("touchend", (e) => {
    isDragging = false;
    container.querySelector('.progress-bar').style.height =
      window.innerWidth <= 768 ? '10px' : '8px';
  });

  // Mouse handling with enhanced sensitivity
  container.addEventListener("mousedown", (e) => {
    isDragging = true;
    const rect = container.getBoundingClientRect();
    const percent = (e.clientX - rect.left) / rect.width;

    if (E.audio.duration) {
      E.audio.currentTime = E.audio.duration * percent;
    }
  });

  container.addEventListener("mousemove", (e) => {
    const rect = container.getBoundingClientRect();
    const percent = ((e.clientX - rect.left) / rect.width) * 100;
    progressHover.style.width = `${percent}%`;

    if (isDragging && E.audio.duration) {
      E.audio.currentTime = E.audio.duration * (percent / 100);
    }
  });

  // Global mouse up handler
  document.addEventListener("mouseup", () => {
    isDragging = false;
  });

  // Prevent text selection while dragging
  container.addEventListener('selectstart', (e) => {
    if (isDragging) e.preventDefault();
  });
}

// Initialize enhanced progress bars
document.addEventListener('DOMContentLoaded', () => {
  setupProgressBar(E.progressContainer, E.progressHover);
  setupProgressBar(E.fullProgressContainer, E.fullProgressHover);
});
  </script>
  <script>
    /**
 * Session Management Enhancement
 */
class SessionManager {
  constructor() {
    this.checkInterval = 10000; // Check every 10 seconds
    this.isCheckingSession = false;
    this.sessionInvalidated = false;
    this.initialize();
  }

  initialize() {
    // Start periodic checks
    this.startChecking();

    // Listen for visibility changes
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') {
        this.checkSessionStatus();
      }
    });

    // Check when user interacts after inactivity
    let lastActivity = Date.now();
    const activityEvents = ['mousedown', 'keydown', 'touchstart', 'click'];

    activityEvents.forEach(event => {
      document.addEventListener(event, () => {
        const now = Date.now();
        if (now - lastActivity > 30000) { // If inactive for 30s
          this.checkSessionStatus();
        }
        lastActivity = now;
      });
    });
  }

  async checkSessionStatus() {
    if (this.isCheckingSession || this.sessionInvalidated) return;

    this.isCheckingSession = true;

    try {
      const response = await fetch('/api/session-status');
      const data = await response.json();

      if (!response.ok || !data.valid) {
        this.sessionInvalidated = true;
        this.showSessionPopup(data.reason);
      }
    } catch (error) {
      console.error('Session check error:', error);
    } finally {
      this.isCheckingSession = false;
    }
  }

  startChecking() {
    setInterval(() => this.checkSessionStatus(), this.checkInterval);
  }

  showSessionPopup(reason) {
    // Stop all audio playback
    if (window.E && window.E.audio) {
      window.E.audio.pause();
    }

    // Create popup elements
    const overlay = document.createElement('div');
    overlay.className = 'session-popup-overlay';

    const popup = document.createElement('div');
    popup.className = 'session-popup';

    let title, message;
    switch (reason) {
      case 'logged_out_elsewhere':
        title = 'Session Ended';
        message = 'Your account has been logged in from another device. For security reasons, this session has been closed.';
        break;
      case 'expired':
        title = 'Session Expired';
        message = 'Your session has expired. Please log in again to continue.';
        break;
      default:
        title = 'Connection Lost';
        message = 'Your session is no longer active. Please log in again to continue.';
    }

    popup.innerHTML = `
      <div class="session-popup-icon">
        <span class="material-icons">error_outline</span>
      </div>
      <div class="session-popup-title">${title}</div>
      <div class="session-popup-message">${message}</div>
      <button class="session-popup-button">Login Again</button>
    `;

    // Add to document
    document.body.appendChild(overlay);
    document.body.appendChild(popup);

    // Handle button click
    const button = popup.querySelector('button');
    button.addEventListener('click', () => {
      window.location.href = '/login';
    });
  }
}

// Initialize session manager
document.addEventListener('DOMContentLoaded', () => {
  window.sessionManager = new SessionManager();
});
class FestiveBackgroundSystem {
  constructor() {
    this.particleInterval = null;
    this.fps = 60;
    this.styles = `
      .bg-animation-wrapper {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
        overflow: hidden;
        pointer-events: none;
      }

      .festive-background {
        position: absolute;
        inset: -50px;
        opacity: 0.3;
        background: linear-gradient(
          45deg,
          #ff9a9e,    /* Light pink */
          #fad0c4,    /* Peach */
          #a18cd1,    /* Light purple */
          #fbc2eb,    /* Pink */
          #ff5458,    /* Bright red */
          #ffc853,    /* Yellow */
          #70ff57,    /* Green */
          #45caff     /* Blue */
        );
        background-size: 800% 800%;
        animation:
          gradientFlow 30s ease infinite,
          colorPulse 15s ease-in-out infinite;
        filter: blur(100px);
      }

      .festive-background::after {
        content: '';
        position: absolute;
        inset: 0;
        background: radial-gradient(
          circle at center,
          transparent 0%,
          rgba(0, 0, 0, 0.2) 100%
        );
      }

      .festive-particle {
        position: fixed;
        pointer-events: none;
        width: 10px;
        height: 10px;
        background: white;
        border-radius: 50%;
        opacity: 0;
        z-index: -1;
        transform-origin: center;
        will-change: transform, opacity;
      }

      @keyframes gradientFlow {
        0% { background-position: 0% 0%; }
        25% { background-position: 100% 50%; }
        50% { background-position: 50% 100%; }
        75% { background-position: 0% 50%; }
        100% { background-position: 0% 0%; }
      }

      @keyframes colorPulse {
        0%, 100% { filter: blur(100px) hue-rotate(0deg); }
        25% { filter: blur(100px) hue-rotate(90deg); }
        50% { filter: blur(100px) hue-rotate(180deg); }
        75% { filter: blur(100px) hue-rotate(270deg); }
      }

      @keyframes particleFloat {
        0% {
          transform: translateY(0) rotate(0deg);
          opacity: 0;
        }
        20% { opacity: 0.8; }
        100% {
          transform: translateY(-100vh) rotate(360deg);
          opacity: 0;
        }
      }

      @media (prefers-reduced-motion: reduce) {
        .festive-background {
          animation: none;
          background-size: 100% 100%;
          background-position: center;
        }
        .festive-particle {
          display: none;
        }
      }
    `;

    this.colors = [
      '#FF5458', // Red (Gulal)
      '#FFC853', // Yellow (Turmeric)
      '#70FF57', // Green (Spring)
      '#45CAFF', // Blue (Sky)
      '#FF9A9E', // Pink
      '#FAD0C4', // Peach
      '#A18CD1', // Purple
      '#FBC2EB'  // Light pink
    ];

    this.init();
  }

  init() {
    this.injectStyles();
    this.createBackgroundElements();
    this.startParticleSystem();
    this.setupPerformanceMonitoring();
    this.handleVisibilityChange();
  }

  injectStyles() {
    const styleSheet = document.createElement('style');
    styleSheet.textContent = this.styles;
    document.head.appendChild(styleSheet);
  }

  createBackgroundElements() {
    const wrapper = document.createElement('div');
    wrapper.className = 'bg-animation-wrapper';

    const background = document.createElement('div');
    background.className = 'festive-background';

    wrapper.appendChild(background);
    document.body.appendChild(wrapper);
  }

  createParticle() {
    if (document.hidden) return;

    const particle = document.createElement('div');
    particle.className = 'festive-particle';

    // Random properties
    const size = Math.random() * 15 + 5;
    const left = Math.random() * 100;
    const duration = Math.random() * 2 + 2;
    const color = this.colors[Math.floor(Math.random() * this.colors.length)];

    particle.style.cssText = `
      left: ${left}vw;
      width: ${size}px;
      height: ${size}px;
      background: ${color};
      animation: particleFloat ${duration}s ease-in-out forwards;
      box-shadow: 0 0 ${size/2}px rgba(255,255,255,0.5);
    `;

    document.body.appendChild(particle);

    // Clean up particle
    particle.addEventListener('animationend', () => {
      particle.remove();
    });
  }

  startParticleSystem() {
    const spawnParticles = () => {
      if (document.hidden) return;
      const count = this.fps > 30 ? 3 : 1;
      for (let i = 0; i < count; i++) {
        this.createParticle();
      }
    };

    this.particleInterval = setInterval(spawnParticles, 1000);
  }

  setupPerformanceMonitoring() {
    let frameCount = 0;
    let lastTime = performance.now();

    const checkPerformance = () => {
      frameCount++;
      const currentTime = performance.now();

      if (currentTime - lastTime >= 1000) {
        this.fps = frameCount;
        frameCount = 0;
        lastTime = currentTime;
      }

      requestAnimationFrame(checkPerformance);
    };

    requestAnimationFrame(checkPerformance);
  }

  handleVisibilityChange() {
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        clearInterval(this.particleInterval);
      } else {
        this.startParticleSystem();
      }
    });
  }
}

// Initialize the system when the DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  window.festiveBackground = new FestiveBackgroundSystem();
});
  </script>
  <script>
    // Enhanced smooth seeking with both slide and tap support
    function initializeSmoothSeek() {
  const progressContainer = document.querySelector('.progress-container');
  const progressBar = document.querySelector('.progress-bar');
  const progress = document.querySelector('.progress');

  if (!progressContainer || !progressBar || !progress) return;

  let isDragging = false;
  let startX = 0;
  let startProgress = 0;

  // Touch event handlers
  progressContainer.addEventListener('touchstart', (e) => {
    isDragging = true;
    startX = e.touches[0].clientX;
    startProgress = progress.style.width ? parseInt(progress.style.width) : 0;

    // Get immediate seek position on tap
    const rect = progressContainer.getBoundingClientRect();
    const percent = (e.touches[0].clientX - rect.left) / rect.width;
    if (E.audio.duration) {
      E.audio.currentTime = E.audio.duration * percent;
      syncProgress();
    }
  }, { passive: true });

  progressContainer.addEventListener('touchmove', (e) => {
    if (!isDragging) return;

    const rect = progressContainer.getBoundingClientRect();
    const percent = (e.touches[0].clientX - rect.left) / rect.width;
    const boundedPercent = Math.max(0, Math.min(1, percent));

    progress.style.width = `${boundedPercent * 100}%`;

    if (E.audio.duration) {
      E.audio.currentTime = E.audio.duration * boundedPercent;
      syncProgress();
    }
  }, { passive: true });

  progressContainer.addEventListener('touchend', () => {
    isDragging = false;
  });

  // Mouse event handlers
  progressContainer.addEventListener('mousedown', (e) => {
    isDragging = true;
    startX = e.clientX;
    startProgress = progress.style.width ? parseInt(progress.style.width) : 0;

    const rect = progressContainer.getBoundingClientRect();
    const percent = (e.clientX - rect.left) / rect.width;
    if (E.audio.duration) {
      E.audio.currentTime = E.audio.duration * percent;
      syncProgress();
    }
  });

  document.addEventListener('mousemove', (e) => {
    if (!isDragging) return;

    const rect = progressContainer.getBoundingClientRect();
    const percent = (e.clientX - rect.left) / rect.width;
    const boundedPercent = Math.max(0, Math.min(1, percent));

    progress.style.width = `${boundedPercent * 100}%`;

    if (E.audio.duration) {
      E.audio.currentTime = E.audio.duration * boundedPercent;
      syncProgress();
    }
  });

  document.addEventListener('mouseup', () => {
    isDragging = false;
  });
}
// Initialize
document.addEventListener('DOMContentLoaded', initializeSmoothSeek);
  </script>
  <script>

  </script>
</body>
</html>

